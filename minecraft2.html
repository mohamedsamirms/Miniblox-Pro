<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <title>MiniBlox Pro Singleplayer</title>
    <style>
        /* Hide scrollbars while keeping scroll functionality */
        ::-webkit-scrollbar {
            display: none;
        }
        
        * {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            z-index: 1;
        }

        body.mobile-mode {
            touch-action: none;
            overscroll-behavior: none;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-family: 'Arial', sans-serif;
        }
        
        #loading h1 {
            font-size: 48px;
            margin: 0 0 20px 0;
            color: #00a2ff;
            text-shadow: 0 0 20px rgba(0,162,255,0.5);
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        #loading p {
            font-size: 18px;
            margin: 10px 0;
            color: #aaa;
        }
        
        #loading-bar {
            width: 300px;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #00a2ff;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(0,162,255,0.3);
        }
        
        #loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00a2ff, #00ffff);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        #ui { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: white; 
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        #corner-settings-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001;
            display: none;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(0,0,0,0.7);
            color: #fff;
            cursor: pointer;
            font-weight: bold;
        }

        #corner-settings-btn:hover {
            background: rgba(0,162,255,0.45);
        }
        
        #chat { 
            position: absolute; 
            bottom: 10px; 
            left: 10px; 
            width: 300px; 
            background: rgba(0,0,0,0.8); 
            color: white; 
            padding: 10px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 700;
        }
        
        #chat-input { 
            width: calc(100% - 20px); 
            margin-top: 10px; 
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #00a2ff;
            color: white;
            border-radius: 5px;
        }
        
        button { 
            margin: 5px; 
            padding: 8px 15px; 
            background: #00a2ff;
            border: none; 
            color: white; 
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }
        button:hover { transform: scale(1.05); background: #0080ff; }
        
        #controls-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #settings {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-height: 600px;
            background: rgba(20,20,20,0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(0,162,255,0.5);
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0,162,255,0.3);
            overflow-y: auto;
        }
        
        #settings h2 {
            margin-top: 0;
            color: #00a2ff;
            text-align: center;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .control-label {
            color: #00a2ff;
            flex: 1;
            font-weight: bold;
        }
        
        .control-key {
            background: rgba(0,162,255,0.2);
            color: #00a2ff;
            border: 1px solid #00a2ff;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
            text-align: center;
        }
        
        .control-key:hover {
            background: rgba(0,162,255,0.4);
            transform: scale(1.05);
        }
        
        .control-key.recording {
            background: rgba(255,100,100,0.5);
            border-color: #ff6464;
            animation: blink 0.5s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #settings-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        #settings-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        #reset-controls {
            background: #ff6464;
            color: white;
        }
        
        #reset-controls:hover {
            background: #ff8484;
        }
        
        #close-settings {
            background: #00a2ff;
            color: white;
        }
        
        #close-settings:hover {
            background: #00c2ff;
        }
        
        #health-bar {
            position: absolute;
            top: 80px;
            right: 10px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
            z-index: 700;
        }
        
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff4444, #44ff44);
            border-radius: 8px;
        }
        
        #save-status {
            position: fixed;
            top: 40px;
            right: 10px;
            background: rgba(0, 162, 255, 0.2);
            border: 2px solid #00a2ff;
            color: #00a2ff;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            z-index: 500;
            pointer-events: none;
            animation: fadeInOut 0.6s ease-in-out;
            text-shadow: 0 0 10px rgba(0, 162, 255, 0.5);
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 99;
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        
        .crosshair::before {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }
        
        .crosshair::after {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }
        
        #inventory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            max-height: 500px;
            background: rgba(20,20,20,0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(0,162,255,0.5);
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0,162,255,0.3);
        }
        
        #inventory h2 {
            margin-top: 0;
            color: #00a2ff;
            text-align: center;
        }
        
        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            overflow-y: auto;
            flex: 1;
            margin-bottom: 15px;
        }

        #armor-panel {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        #armor-panel h3 {
            margin: 0 0 8px 0;
            color: #9ee7ff;
            font-size: 14px;
        }

        #armor-slots {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
        }

        .armor-slot {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 6px;
            color: #fff;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
        }

        .armor-slot button {
            margin: 0;
            padding: 4px 6px;
            font-size: 11px;
        }
        
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 700;
        }
        
        .inventory-slot {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 30px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .inventory-slot:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .inventory-slot.active {
            border-color: #00a2ff;
            background: rgba(0,162,255,0.3);
            box-shadow: 0 0 10px rgba(0,162,255,0.5);
        }

        .inventory-slot.disabled {
            opacity: 0.4;
        }

        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 11px;
            background: rgba(0,0,0,0.6);
            padding: 1px 4px;
            border-radius: 4px;
            color: white;
        }
        
        .hotbar-slot {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            position: relative;
        }
        .hotbar-slot.disabled {
            opacity: 0.4;
        }
        
        .hotbar-slot.active {
            border-color: #00a2ff;
            background: rgba(0,162,255,0.3);
        }

        .swap-hover {
            border-color: #ffd166 !important;
            box-shadow: 0 0 10px rgba(255, 209, 102, 0.7);
        }
        
        #inventory-close {
            align-self: flex-end;
            background: #ff4444;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        #inventory-close:hover {
            background: #ff6666;
        }

        #inventory-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #inventory-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            background: #00a2ff;
            color: white;
        }

        #inventory-buttons button:hover {
            background: #00c2ff;
        }
        
        #inventory-trash {
            position: fixed;
            top: 50%;
            left: calc(50% + 220px);
            transform: translateY(-50%);
            width: 80px;
            height: 80px;
            background: rgba(255,68,68,0.2);
            border: 3px dashed rgba(255,68,68,0.5);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            z-index: 999;
            transition: all 0.3s;
            cursor: grab;
        }
        
        #inventory-trash.drag-over {
            background: rgba(255,68,68,0.5);
            border-color: rgba(255,68,68,1);
            box-shadow: 0 0 20px rgba(255,68,68,0.5);
            transform: scale(1.1);
        }

        #crafting {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 540px;
            max-height: 650px;
            background: rgba(20,20,20,0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(0,162,255,0.5);
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0,162,255,0.3);
            overflow-y: auto;
        }

        #crafting h2 {
            margin-top: 0;
            color: #00a2ff;
            text-align: center;
        }

        #crafting-hint {
            color: #aaa;
            font-size: 13px;
            margin-bottom: 10px;
            text-align: center;
        }

        #crafting-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .recipe-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .recipe-grid {
            display: grid;
            grid-template-columns: repeat(3, 30px);
            grid-template-rows: repeat(3, 30px);
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 6px;
            border-radius: 6px;
        }

        .recipe-cell {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.08);
            border-radius: 4px;
            font-size: 16px;
        }

        .recipe-output {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #fff;
            font-weight: bold;
        }

        .recipe-output .slot-count {
            position: static;
            background: rgba(0,0,0,0.4);
        }

        .recipe-actions button {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #00a2ff;
            color: white;
            transition: all 0.2s;
        }

        .recipe-actions button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        #crafting-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #crafting-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            background: #00a2ff;
            color: white;
        }

        #crafting-buttons button:hover {
            background: #00c2ff;
        }

        #quick-menu,
        #chest-menu,
        #mods-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 540px;
            max-height: 680px;
            background: rgba(20,20,20,0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(0,162,255,0.5);
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0,162,255,0.3);
            overflow-y: auto;
        }

        #quick-menu h2,
        #chest-menu h2,
        #mods-menu h2 {
            margin-top: 0;
            color: #00a2ff;
            text-align: center;
        }

        #quick-menu-buttons,
        #chest-buttons,
        #mods-buttons {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        #quick-menu-buttons button,
        #chest-buttons button,
        #mods-buttons button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #00a2ff;
            color: white;
            font-size: 14px;
            transition: all 0.2s;
        }

        #quick-menu-buttons button:hover,
        #chest-buttons button:hover,
        #mods-buttons button:hover {
            background: #00c2ff;
        }

        #chest-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .chest-row {
            display: grid;
            grid-template-columns: 1.5fr 1fr 1fr 0.7fr 0.7fr;
            gap: 8px;
            align-items: center;
            padding: 8px;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
            color: white;
            font-size: 13px;
        }

        .chest-row button {
            padding: 6px;
            margin: 0;
            font-size: 12px;
        }

        #mods-code {
            width: 100%;
            min-height: 170px;
            background: rgba(0,0,0,0.4);
            color: #c8e8ff;
            border: 1px solid rgba(0,162,255,0.5);
            border-radius: 6px;
            resize: vertical;
            font-family: Consolas, monospace;
            padding: 10px;
            box-sizing: border-box;
        }

        #mods-list {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mod-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
            color: white;
            font-size: 13px;
            border: 1px solid rgba(255,255,255,0.12);
        }
        
        /* Menu Styling */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        #main-menu h1 {
            font-size: 64px;
            margin: 0 0 60px 0;
            color: #00a2ff;
            text-shadow: 0 0 30px rgba(0,162,255,0.7);
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .menu-button {
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(135deg, #00a2ff, #0080ff);
            border: 2px solid #00a2ff;
            color: white;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(0,162,255,0.3);
        }
        
        .menu-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0,162,255,0.7);
            background: linear-gradient(135deg, #0080ff, #0060ff);
        }
        
        .menu-button:active {
            transform: scale(0.98);
        }
        
        #unavailable-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        #unavailable-message h2 {
            font-size: 48px;
            color: #ff6464;
            text-shadow: 0 0 20px rgba(255,100,100,0.5);
            margin-bottom: 40px;
        }
        
        #unavailable-message p {
            font-size: 24px;
            color: #aaa;
            margin: 20px 0;
        }
        
        #world-slots {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 10000;
            padding: 40px 20px;
        }
        
        #world-slots h1 {
            font-size: 48px;
            margin: 0 0 20px 0;
            color: #00a2ff;
            text-shadow: 0 0 30px rgba(0,162,255,0.7);
        }
        
        #back-to-menu {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #ff6464;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        #back-to-menu:hover {
            background: #ff8484;
            transform: scale(1.05);
        }
        
        #create-world-button {
            margin-top: 20px;
            padding: 12px 40px;
            background: linear-gradient(135deg, #00a2ff, #0080ff);
            border: 2px solid #00a2ff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(0,162,255,0.3);
        }
        
        #create-world-button:hover {
            background: linear-gradient(135deg, #0080ff, #0060ff);
            box-shadow: 0 0 30px rgba(0,162,255,0.7);
            transform: scale(1.05);
        }
        
        #slots-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 800px;
            width: 100%;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .world-slot {
            background: rgba(0,162,255,0.1);
            border: 2px solid rgba(0,162,255,0.5);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .world-slot:hover {
            background: rgba(0,162,255,0.2);
            border-color: #00a2ff;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0,162,255,0.5);
        }
        
        .world-slot-title {
            font-size: 18px;
            font-weight: bold;
            color: #00a2ff;
            word-break: break-word;
        }
        
        .world-slot-info {
            font-size: 12px;
            color: #aaa;
        }
        
        .world-slot-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .slot-button {
            flex: 1;
            padding: 8px;
            font-size: 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            background: #00a2ff;
            color: white;
        }
        
        .slot-button:hover {
            background: #0080ff;
            transform: scale(1.05);
        }
        
        .slot-button.delete {
            background: #ff6464;
        }
        
        .slot-button.delete:hover {
            background: #ff8484;
        }
        
        #rename-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.95);
            border: 2px solid #00a2ff;
            border-radius: 10px;
            padding: 30px;
            z-index: 10001;
            display: none;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 30px rgba(0,162,255,0.5);
            min-width: 300px;
        }
        
        #rename-dialog h2 {
            color: #00a2ff;
            margin: 0;
            text-align: center;
        }
        
        #rename-input {
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #00a2ff;
            color: white;
            border-radius: 5px;
            font-size: 16px;
        }
        
        #rename-input::placeholder {
            color: #666;
        }
        
        #rename-dialog-buttons {
            display: flex;
            gap: 10px;
        }
        
        #rename-dialog-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        #rename-confirm {
            background: #00a2ff;
            color: white;
        }
        
        #rename-confirm:hover {
            background: #0080ff;
        }
        
        #rename-cancel {
            background: #ff6464;
            color: white;
        }
        
        #rename-cancel:hover {
            background: #ff8484;
        }
        
        #conversation-load-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.95);
            border: 2px solid #00a2ff;
            border-radius: 10px;
            padding: 30px;
            z-index: 10001;
            display: none;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 30px rgba(0,162,255,0.5);
            min-width: 400px;
            max-height: 60vh;
        }
        
        #conversation-load-dialog h2 {
            color: #00a2ff;
            margin: 0;
            text-align: center;
        }
        
        #conversations-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .conversation-item {
            background: rgba(0,162,255,0.1);
            border: 1px solid rgba(0,162,255,0.5);
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .conversation-item:hover {
            background: rgba(0,162,255,0.2);
            border-color: #00a2ff;
            transform: scale(1.02);
        }
        
        .conversation-item-title {
            color: #00a2ff;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .conversation-item-info {
            font-size: 11px;
            color: #888;
        }
        
        #conversation-dialog-buttons {
            display: flex;
            gap: 10px;
        }
        
        #conversation-dialog-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        #conversation-close {
            background: #00a2ff;
            color: white;
        }
        
        #conversation-close:hover {
            background: #0080ff;
        }

        #conversation-delete-all {
            background: #ff4444;
            color: white;
        }

        #conversation-delete-all:hover {
            background: #ff6666;
        }
        
        #conversation-rename-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.95);
            border: 2px solid #00a2ff;
            border-radius: 10px;
            padding: 30px;
            z-index: 10002;
            display: none;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 30px rgba(0,162,255,0.5);
            min-width: 300px;
        }
        
        #conversation-rename-dialog h2 {
            color: #00a2ff;
            margin: 0;
            text-align: center;
        }
        
        #conversation-rename-input {
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #00a2ff;
            color: white;
            border-radius: 5px;
            font-size: 16px;
        }
        
        #conversation-rename-input::placeholder {
            color: #666;
        }
        
        #conversation-rename-buttons {
            display: flex;
            gap: 10px;
        }
        
        #conversation-rename-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        #conversation-rename-confirm {
            background: #00a2ff;
            color: white;
        }
        
        #conversation-rename-confirm:hover {
            background: #0080ff;
        }
        
        #conversation-rename-cancel {
            background: #ff6464;
            color: white;
        }
        
        #conversation-rename-cancel:hover {
            background: #ff8484;
        }
        
        .conversation-item-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        .conversation-item-button {
            flex: 1;
            padding: 5px;
            font-size: 11px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0,162,255,0.2);
            color: #00a2ff;
            border: 1px solid rgba(0,162,255,0.5);
        }
        
        .conversation-item-button:hover {
            background: rgba(0,162,255,0.4);
        }
        
        .conversation-item-button.delete {
            background: rgba(255,100,100,0.2);
            color: #ff6464;
            border-color: rgba(255,100,100,0.5);
        }
        
        .conversation-item-button.delete:hover {
            background: rgba(255,100,100,0.4);
        }

        #create-world-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.95);
            border: 2px solid #00a2ff;
            border-radius: 10px;
            padding: 30px;
            z-index: 10002;
            display: none;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 30px rgba(0,162,255,0.5);
            min-width: 300px;
        }
        
        #create-world-dialog h2 {
            color: #00a2ff;
            margin: 0;
            text-align: center;
        }
        
        #create-world-input {
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #00a2ff;
            color: white;
            border-radius: 5px;
            font-size: 16px;
        }
        
        #create-world-input::placeholder {
            color: #666;
        }
        
        #create-world-buttons {
            display: flex;
            gap: 10px;
        }
        
        #create-world-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        #create-world-confirm {
            background: #00a2ff;
            color: white;
        }
        
        #create-world-confirm:hover {
            background: #0080ff;
        }
        
        #create-world-cancel {
            background: #ff6464;
            color: white;
        }
        
        #create-world-cancel:hover {
            background: #ff8484;
        }

        #mobile-controls {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1200;
            display: none;
            pointer-events: none;
            padding: max(10px, env(safe-area-inset-bottom));
        }

        #mobile-joystick-zone,
        #mobile-actions {
            pointer-events: auto;
        }

        #mobile-joystick-zone {
            position: fixed;
            left: 16px;
            bottom: calc(16px + env(safe-area-inset-bottom));
            width: 140px;
            height: 140px;
        }

        #mobile-joystick-base {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.35);
            background: rgba(0,0,0,0.35);
            position: relative;
            backdrop-filter: blur(4px);
        }

        #mobile-joystick-knob {
            width: 62px;
            height: 62px;
            border-radius: 50%;
            background: rgba(0,162,255,0.75);
            border: 2px solid rgba(255,255,255,0.5);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.05s linear;
        }

        #mobile-actions {
            position: fixed;
            right: 16px;
            bottom: calc(16px + env(safe-area-inset-bottom));
            display: grid;
            grid-template-columns: repeat(2, minmax(62px, 76px));
            gap: 8px;
        }

        .mobile-btn {
            min-height: 52px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.35);
            background: rgba(0,0,0,0.45);
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            padding: 8px;
            touch-action: none;
        }

        body.mobile-mode #mobile-controls {
            display: block;
        }

        body.mobile-mode #chat {
            width: min(88vw, 360px);
            max-height: 34vh;
        }

        @media (max-width: 1024px) {
            #settings,
            #inventory,
            #crafting,
            #quick-menu,
            #mods-menu,
            #chest-menu {
                width: min(94vw, 680px);
                max-height: 86vh;
            }
        }

        @media (max-width: 768px) {
            #ui {
                transform: scale(0.92);
                transform-origin: top left;
                max-width: 92vw;
            }

            #chat {
                left: 8px;
                bottom: 100px;
            }

            #hotbar {
                bottom: 6px;
            }

            #controls-info {
                display: none !important;
            }
        }
</style>
</head>
<body>
    <div id="loading">
        <h1>üßä MiniBlox Pro</h1>
        <p>Loading Game World...</p>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
        <p id="loading-text" style="margin-top: 20px; font-size: 14px;">Initializing...</p>
    </div>
    
    <div id="main-menu">
        <h1>üßä MiniBlox Pro</h1>
        <div class="menu-buttons">
            <button class="menu-button" onclick="startSingleplayer()">üë§ Singleplayer</button>
            <button class="menu-button" onclick="startMultiplayer()">üåê Multiplayer</button>
            <button class="menu-button" onclick="downloadAppVersion()">Download App Version</button>
        </div>
    </div>

    <div id="unavailable-message">
        <h2>‚ö†Ô∏è Unavailable</h2>
        <p>Multiplayer mode is coming soon!</p>
        <p id="countdown-timer">Returning to menu in 10 seconds...</p>
    </div>
    
    <div id="world-slots">
        <button id="back-to-menu" onclick="backToMainMenu()">‚Üê Back to Menu</button>
        <h1>My Worlds</h1>
        <button id="create-world-button" onclick="openCreateWorldDialog()">‚ú® Create World</button>
        <div id="slots-grid"></div>
    </div>
    
    <div id="rename-dialog">
        <h2>Rename World</h2>
        <input id="rename-input" type="text" placeholder="Enter world name...">
        <div id="rename-dialog-buttons">
            <button id="rename-confirm" onclick="confirmRename()">Confirm</button>
            <button id="rename-cancel" onclick="cancelRename()">Cancel</button>
        </div>
    </div>
    
    <div id="conversation-load-dialog">
        <h2>Load Conversation</h2>
        <div id="conversations-list"></div>
        <div id="conversation-dialog-buttons">
            <button id="conversation-delete-all" onclick="deleteAllConversations()">Delete All</button>
            <button id="conversation-close" onclick="closeConversationDialog()">Close</button>
        </div>
    </div>
    
    <div id="conversation-rename-dialog">
        <h2>Rename Conversation</h2>
        <input id="conversation-rename-input" type="text" placeholder="Enter conversation name...">
        <div id="conversation-rename-buttons">
            <button id="conversation-rename-confirm" onclick="confirmConversationRename()">Confirm</button>
            <button id="conversation-rename-cancel" onclick="cancelConversationRename()">Cancel</button>
        </div>
    </div>
    
    <div id="create-world-dialog">
        <h2>Create New World</h2>
        <input id="create-world-input" type="text" placeholder="Enter world name...">
        <div style="display: flex; flex-direction: column; gap: 8px; color: white;">
            <label for="create-world-mode">Game Mode</label>
            <select id="create-world-mode" style="padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid #00a2ff;">
                <option value="survival">Survival</option>
                <option value="creative">Creative</option>
            </select>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; color: white;">
            <input id="create-world-structures" type="checkbox" style="width: 18px; height: 18px; cursor: pointer;">
            <label for="create-world-structures" style="cursor: pointer; margin: 0;">Add Structures</label>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; color: white;">
            <input id="create-world-villagers" type="checkbox" checked style="width: 18px; height: 18px; cursor: pointer;">
            <label for="create-world-villagers" style="cursor: pointer; margin: 0;">Spawn Villagers</label>
        </div>
        <div id="create-world-buttons">
            <button id="create-world-confirm" onclick="confirmCreateWorld()">Create</button>
            <button id="create-world-cancel" onclick="cancelCreateWorld()">Cancel</button>
        </div>
    </div>
    
    <div id="ui" style="display: none;">
        <h2 style="margin:0; color:#00a2ff;">üßä MiniBlox Pro</h2>
        <div>Mode: <span id="game-mode-label">Survival</span></div>
        <div>Position: <span id="position">0, 0, 0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Armor: <span id="armor-value">0%</span></div>
        <div style="font-size: 11px; color: #888; margin-top: 5px;">Auto-saved: <span id="last-save-time">--:--</span></div>
        
        <div style="margin-top: 10px;">
            <button onclick="spawnBlock()">üß± Place Block</button>
            <button onclick="toggleFly()" id="fly-btn">‚úàÔ∏è Fly: OFF</button>
        </div>
    </div>
    
    <input type="file" id="game-file-input" accept=".json" style="display: none;" onchange="handleLoadGameFile(event)">
    
    <div class="crosshair"></div>
    
    <div id="save-status" style="display: none;">
        <span id="save-status-text">Saving...</span>
    </div>
    
    <div id="health-bar" style="display: none;">
        <div id="health-fill"></div>
    </div>
    
        <div id="inventory">
        <h2>Inventory</h2>
        <div id="armor-panel">
            <h3>Armor</h3>
            <div id="armor-slots"></div>
        </div>
        <div id="inventory-grid"></div>
        <div id="inventory-buttons">
            <button onclick="toggleCrafting()">Open Crafting</button>
            <button id="inventory-close" onclick="toggleInventory()">Close (Press ` to close)</button>
        </div>
    </div>
    
    <div id="hotbar">
    </div>
    
    <div id="inventory-trash" style="display: none;">üóëÔ∏è</div>
    
    <div id="crafting">
        <h2>Crafting</h2>
        <div id="crafting-hint">Stand near a Crafting Table to unlock advanced recipes.</div>
        <div id="crafting-list"></div>
        <div id="crafting-buttons">
            <button onclick="toggleCrafting()">Close</button>
        </div>
    </div>
    <button id="corner-settings-btn" onclick="toggleSettings()">‚öô Settings</button>

    <div id="chest-menu">
        <h2>Chest</h2>
        <div style="color: #aaa; font-size: 13px; margin-bottom: 10px; text-align: center;">
            `+` moves one item to chest, `-` moves one item to your inventory.
        </div>
        <div id="chest-list"></div>
        <div id="chest-buttons">
            <button onclick="quickStoreSelectedItem()">Store Selected Item</button>
            <button onclick="quickTakeSelectedItem()">Take Selected Item</button>
            <button onclick="toggleChestMenu(false)">Close Chest</button>
        </div>
    </div>

    <div id="mods-menu">
        <h2>Mods & Plugins</h2>
        <div style="color: #aaa; font-size: 13px; margin-bottom: 8px;">
            Load JavaScript mods/plugins. They can register hooks through `MiniBloxAPI`.
        </div>
        <textarea id="mods-code" placeholder="// Example:
MiniBloxAPI.registerPlugin({
  id: 'double-bricks',
  name: 'Double Bricks',
  onCraft(ctx) {
    if (ctx.recipeId === 'stone_bricks') {
      ctx.inventoryCounts[ctx.outputType] += ctx.outputCount;
    }
  }
});"></textarea>
        <input type="file" id="mod-file-input" accept=".js,.txt" style="display: none;" onchange="handleModFile(event)">
        <div id="mods-buttons">
            <button onclick="installModFromTextarea()">Install From Text</button>
            <button onclick="openModFilePicker()">Install From File</button>
            <button onclick="clearAllModsAndPlugins()">Remove All</button>
            <button onclick="toggleModsMenu()">Close</button>
        </div>
        <div id="mods-list"></div>
    </div>

    <div id="quick-menu">
        <h2>Paused</h2>
        <div id="quick-menu-buttons">
            <button onclick="toggleQuickMenu(false)">Resume</button>
            <button onclick="toggleInventory()">Inventory</button>
            <button onclick="toggleCrafting()">Crafting</button>
            <button onclick="toggleSettings()">Settings</button>
            <button onclick="toggleModsMenu()">Mods & Plugins</button>
            <button onclick="downloadAppVersion()">Download App Version</button>
            <button onclick="saveGameToLocalStorage()">Save Now</button>
            <button onclick="saveAndQuitToMenu()" style="grid-column: 1 / -1; background: #ff6464;">Save & Quit To Menu</button>
        </div>
    </div>
    
    <div id="settings">
        <h2>Settings</h2>
        <div id="controls-list"></div>
        <div id="settings-buttons">
            <button id="reset-controls" onclick="resetControlsToDefault()">Reset to Default</button>
            <button id="close-settings" onclick="toggleSettings()">Close</button>
        </div>
    </div>
    
    <div id="chat" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <span style="font-weight: bold; color: #00a2ff;">Chat</span>
            <button onclick="loadConversation()" style="padding: 5px 10px; background: #00a2ff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">üìÇ Load Conversation</button>
        </div>
        <div id="messages">Welcome to MiniBlox! Press T to chat</div>
        <input id="chat-input" placeholder="Press T to chat..." onkeypress="handleChatKey(event)">
    </div>
    
    <div id="controls-info" style="display: none;"></div>
    <div id="mobile-controls">
        <div id="mobile-joystick-zone">
            <div id="mobile-joystick-base">
                <div id="mobile-joystick-knob"></div>
            </div>
        </div>
        <div id="mobile-actions">
            <button class="mobile-btn" id="mobile-jump-btn">Jump</button>
            <button class="mobile-btn" id="mobile-break-btn">Break</button>
            <button class="mobile-btn" id="mobile-place-btn">Place</button>
            <button class="mobile-btn" id="mobile-interact-btn">Use</button>
            <button class="mobile-btn" id="mobile-inventory-btn">Bag</button>
            <button class="mobile-btn" id="mobile-settings-btn">Menu</button>
        </div>
    </div>

    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
                // ================= SIMPLIFIED CONFIG =================
        const LOCAL_USER_ID = 'local';
        const GRAVITY = -20;
        const JUMP_FORCE = 10;
        const MOVE_SPEED = 5;
        const DEFAULT_MOUSE_SENSITIVITY = 0.002;
        let mouseSensitivity = DEFAULT_MOUSE_SENSITIVITY;
        
        // Block types
        const BLOCK_TYPES = [
            { name: 'Grass', color: 0x7cfc00, emoji: 'üåø' },
            { name: 'Stone', color: 0x808080, emoji: 'ü™®' },
            { name: 'Wood', color: 0x8b4513, emoji: 'ü™µ' },
            { name: 'Brick', color: 0xff4444, emoji: 'üß±' },
            { name: 'Sand', color: 0xf4a460, emoji: 'üèúÔ∏è' },
            { name: 'Dirt', color: 0x8b7355, emoji: 'üü§' },
            { name: 'Ice', color: 0x87ceeb, emoji: '‚ùÑÔ∏è' },
            { name: 'Gold', color: 0xffd700, emoji: '‚õèÔ∏è' },
            { name: 'Diamond', color: 0x00ffff, emoji: 'üíé' },
            { name: 'Obsidian', color: 0x1a1a2e, emoji: '‚¨õ' },
            { name: 'Crafting Table', color: 0x8b5a2b, emoji: 'ÔøΩ Ô∏è' },
            { name: 'Glass', color: 0x88e5ff, emoji: 'ü™ü' },
            { name: 'Stone Bricks', color: 0x9c9c9c, emoji: 'üß©' }
        ];
        const BASE_BLOCK_COUNT = 13;
        const CRAFTING_TABLE_TYPE = 10;
        const MAX_STACK = 999;
        const GLASS_TYPE = 11;
        const STONE_BRICKS_TYPE = 12;
        const CHEST_TYPE = 13;
        BLOCK_TYPES.push({ name: 'Chest', color: 0xb87333, emoji: '[C]' });
        const ENDER_CHEST_TYPE = BLOCK_TYPES.push({ name: 'Ender Chest', color: 0x2f1a4f, emoji: '[EC]' }) - 1;
        const COPPER_TYPE = BLOCK_TYPES.push({ name: 'Copper', color: 0xb87333, emoji: '[Cu]' }) - 1;
        const COAL_TYPE = BLOCK_TYPES.push({ name: 'Coal', color: 0x202020, emoji: '[Co]' }) - 1;
        const IRON_TYPE = BLOCK_TYPES.push({ name: 'Iron', color: 0xb0b0b0, emoji: '[Fe]' }) - 1;
        const EMERALD_TYPE = BLOCK_TYPES.push({ name: 'Emerald', color: 0x00a86b, emoji: '[Em]' }) - 1;
        const RUBY_TYPE = BLOCK_TYPES.push({ name: 'Ruby', color: 0xd1002c, emoji: '[Rb]' }) - 1;
        // ================= GLOBAL VARIABLES =================
        let scene, camera, renderer;
        let currentBlockType = 0;
        let blocks = [];
        let villagers = [];
        let ground;
        const blockMaterialCache = new Map();
        let blockGeometry = null;
        let keys = {};
        let removedMaterials = new Set(); // Track which materials have been removed
        let inventoryCounts = BLOCK_TYPES.map((_, i) => i < BASE_BLOCK_COUNT ? 64 : 0);
        let hotbarSlots = [0, 1, 2, 3, 4, 5, 6, 7, 8];
        let currentHotbarSlot = 0;
        let chestInventories = {};
        let enderChestInventory = BLOCK_TYPES.map(() => 0);
        let activeChestType = 'normal';
        let activeChestKey = null;
        let installedExtensions = [];
        let extensionSourceCache = [];
        let currentGameMode = 'survival';
        let audioContext = null;
        let soundsEnabled = true;
        let voiceState = { stream: null, recorder: null, chunks: [], active: false, recognition: null, recognizing: false };
        let sprintEnabled = false;
        let villagerCounter = 0;
        const ARMOR_PIECES = ['helmet', 'chestplate', 'leggings', 'boots'];
        const ARMOR_REDUCTION = { helmet: 8, chestplate: 12, leggings: 10, boots: 6 };
        let armorSlots = { helmet: null, chestplate: null, leggings: null, boots: null };
        let armorInventory = { helmet: 0, chestplate: 0, leggings: 0, boots: 0 };
        let mouse = { x: 0, y: 0, isDown: false, rightDown: false };
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
        let mobileModeEnabled = isTouchDevice;
        let screenScale = 1;
        let renderScale = 1;
        const mobileInputState = { moveX: 0, moveY: 0, jump: false };
        const mobileTouchState = { joystickId: null, lookId: null, lookLastX: 0, lookLastY: 0 };

        function clampColor(v) {
            return Math.max(0, Math.min(255, Math.round(v)));
        }

        function hexToRgb(hex) {
            return {
                r: (hex >> 16) & 255,
                g: (hex >> 8) & 255,
                b: hex & 255
            };
        }

        function rgbToCss(rgb) {
            return `rgb(${clampColor(rgb.r)}, ${clampColor(rgb.g)}, ${clampColor(rgb.b)})`;
        }

        function shadeRgb(rgb, factor) {
            return {
                r: rgb.r * factor,
                g: rgb.g * factor,
                b: rgb.b * factor
            };
        }

        function hashString(input) {
            let h = 2166136261;
            for (let i = 0; i < input.length; i++) {
                h ^= input.charCodeAt(i);
                h = Math.imul(h, 16777619);
            }
            return h >>> 0;
        }

        function createRng(seed) {
            let state = (seed >>> 0) || 1;
            return () => {
                state = (Math.imul(state, 1664525) + 1013904223) >>> 0;
                return state / 4294967296;
            };
        }

        function makeCanvasTexture(seedKey, painter, size = 64) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const rng = createRng(hashString(seedKey));
            painter(ctx, size, rng);
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.generateMipmaps = false;
            return texture;
        }

        function paintNoise(ctx, size, rng, baseHex, dots = 180, sizeMin = 1, sizeMax = 4, shadeMin = 0.75, shadeMax = 1.25) {
            const base = hexToRgb(baseHex);
            ctx.fillStyle = rgbToCss(base);
            ctx.fillRect(0, 0, size, size);
            for (let i = 0; i < dots; i++) {
                const px = Math.floor(rng() * size);
                const py = Math.floor(rng() * size);
                const dotSize = Math.floor(sizeMin + rng() * (sizeMax - sizeMin + 1));
                const shade = shadeMin + rng() * (shadeMax - shadeMin);
                ctx.fillStyle = rgbToCss(shadeRgb(base, shade));
                ctx.fillRect(px, py, dotSize, dotSize);
            }
        }

        function paintBricks(ctx, size, rng, baseHex, mortarHex = 0x4a4a4a) {
            const base = hexToRgb(baseHex);
            const mortar = hexToRgb(mortarHex);
            ctx.fillStyle = rgbToCss(mortar);
            ctx.fillRect(0, 0, size, size);
            const brickH = Math.max(8, Math.floor(size / 4));
            const brickW = Math.max(12, Math.floor(size / 2));
            for (let y = 0; y < size; y += brickH) {
                const rowOffset = (Math.floor(y / brickH) % 2) * Math.floor(brickW / 2);
                for (let x = -rowOffset; x < size; x += brickW) {
                    const shade = 0.85 + rng() * 0.35;
                    ctx.fillStyle = rgbToCss(shadeRgb(base, shade));
                    ctx.fillRect(x + 1, y + 1, brickW - 2, brickH - 2);
                }
            }
        }

        function paintPlanks(ctx, size, rng, baseHex) {
            const plankH = Math.max(6, Math.floor(size / 8));
            const base = hexToRgb(baseHex);
            for (let y = 0; y < size; y += plankH) {
                const shade = 0.8 + rng() * 0.35;
                ctx.fillStyle = rgbToCss(shadeRgb(base, shade));
                ctx.fillRect(0, y, size, plankH);
                ctx.fillStyle = 'rgba(30,20,10,0.3)';
                ctx.fillRect(0, y, size, 1);
            }
            for (let i = 0; i < 28; i++) {
                const gx = Math.floor(rng() * size);
                const gy = Math.floor(rng() * size);
                const gw = 4 + Math.floor(rng() * 10);
                const gh = 1 + Math.floor(rng() * 3);
                ctx.fillStyle = 'rgba(70,40,20,0.35)';
                ctx.fillRect(gx, gy, gw, gh);
            }
        }

        function paintWoodTop(ctx, size, rng, baseHex) {
            paintNoise(ctx, size, rng, baseHex, 120, 1, 2, 0.9, 1.1);
            const centerX = size / 2;
            const centerY = size / 2;
            const rings = 5;
            for (let i = 1; i <= rings; i++) {
                const radius = (size * i) / (rings * 2.2);
                ctx.strokeStyle = `rgba(70, 40, 20, ${0.22 + i * 0.07})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function paintOre(ctx, size, rng, oreHex) {
            paintNoise(ctx, size, rng, 0x747474, 180, 1, 3, 0.75, 1.3);
            const ore = hexToRgb(oreHex);
            for (let i = 0; i < 18; i++) {
                const x = Math.floor(rng() * (size - 8));
                const y = Math.floor(rng() * (size - 8));
                const w = 3 + Math.floor(rng() * 6);
                const h = 3 + Math.floor(rng() * 6);
                const shade = 0.9 + rng() * 0.4;
                ctx.fillStyle = rgbToCss(shadeRgb(ore, shade));
                ctx.fillRect(x, y, w, h);
            }
        }

        function createFaceTexture(type, faceKey) {
            const block = BLOCK_TYPES[type] || BLOCK_TYPES[0];
            const name = (block.name || '').toLowerCase();
            const seed = `${block.name || 'Block'}:${faceKey}:${type}`;
            if (name === 'grass') {
                if (faceKey === 'top') return makeCanvasTexture(seed, (ctx, size, rng) => paintNoise(ctx, size, rng, 0x4c9d2a, 220, 1, 3, 0.75, 1.35));
                if (faceKey === 'bottom') return makeCanvasTexture(seed, (ctx, size, rng) => paintNoise(ctx, size, rng, 0x8b7355, 180, 1, 3, 0.8, 1.25));
                return makeCanvasTexture(seed, (ctx, size, rng) => {
                    const grassH = Math.floor(size * 0.36);
                    paintNoise(ctx, size, rng, 0x8b7355, 120, 1, 3, 0.8, 1.2);
                    paintNoise(ctx, grassH, rng, 0x5cb933, 140, 1, 3, 0.8, 1.35);
                    ctx.fillStyle = 'rgba(35,80,20,0.25)';
                    ctx.fillRect(0, grassH - 2, size, 2);
                });
            }
            if (name === 'dirt') return makeCanvasTexture(seed, (ctx, size, rng) => paintNoise(ctx, size, rng, 0x8b7355, 200, 1, 3, 0.75, 1.25));
            if (name === 'stone') return makeCanvasTexture(seed, (ctx, size, rng) => paintNoise(ctx, size, rng, 0x808080, 240, 1, 3, 0.75, 1.3));
            if (name === 'stone bricks') return makeCanvasTexture(seed, (ctx, size, rng) => paintBricks(ctx, size, rng, 0x9c9c9c, 0x656565));
            if (name === 'brick') return makeCanvasTexture(seed, (ctx, size, rng) => paintBricks(ctx, size, rng, 0xb6463b, 0x6a2e29));
            if (name === 'wood') {
                if (faceKey === 'top' || faceKey === 'bottom') return makeCanvasTexture(seed, (ctx, size, rng) => paintWoodTop(ctx, size, rng, 0x9c6a3b));
                return makeCanvasTexture(seed, (ctx, size, rng) => paintPlanks(ctx, size, rng, 0x8b5a2b));
            }
            if (name === 'crafting table') {
                if (faceKey === 'top') {
                    return makeCanvasTexture(seed, (ctx, size, rng) => {
                        paintPlanks(ctx, size, rng, 0xa0713e);
                        ctx.strokeStyle = 'rgba(40,25,12,0.85)';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(2, 2, size - 4, size - 4);
                        for (let i = 1; i < 4; i++) {
                            const p = Math.floor((i * size) / 4);
                            ctx.beginPath(); ctx.moveTo(p, 4); ctx.lineTo(p, size - 4); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(4, p); ctx.lineTo(size - 4, p); ctx.stroke();
                        }
                    });
                }
                return makeCanvasTexture(seed, (ctx, size, rng) => paintPlanks(ctx, size, rng, 0x8b5a2b));
            }
            if (name === 'sand') return makeCanvasTexture(seed, (ctx, size, rng) => paintNoise(ctx, size, rng, 0xead089, 260, 1, 2, 0.85, 1.15));
            if (name === 'obsidian') {
                return makeCanvasTexture(seed, (ctx, size, rng) => {
                    paintNoise(ctx, size, rng, 0x1a1a2e, 160, 1, 2, 0.75, 1.15);
                    for (let i = 0; i < 10; i++) {
                        ctx.strokeStyle = 'rgba(120, 80, 170, 0.28)';
                        ctx.lineWidth = 1 + Math.floor(rng() * 2);
                        ctx.beginPath();
                        ctx.moveTo(rng() * size, rng() * size);
                        ctx.lineTo(rng() * size, rng() * size);
                        ctx.stroke();
                    }
                });
            }
            if (name === 'ice') {
                return makeCanvasTexture(seed, (ctx, size, rng) => {
                    paintNoise(ctx, size, rng, 0x9fd7ef, 120, 1, 2, 0.9, 1.2);
                    for (let i = 0; i < 16; i++) {
                        ctx.strokeStyle = 'rgba(240,250,255,0.45)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(rng() * size, rng() * size);
                        ctx.lineTo(rng() * size, rng() * size);
                        ctx.stroke();
                    }
                });
            }
            if (name === 'glass') {
                return makeCanvasTexture(seed, (ctx, size) => {
                    ctx.clearRect(0, 0, size, size);
                    ctx.strokeStyle = 'rgba(180, 230, 255, 0.55)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(1, 1, size - 2, size - 2);
                    ctx.strokeStyle = 'rgba(235, 250, 255, 0.45)';
                    ctx.beginPath();
                    ctx.moveTo(6, size - 12);
                    ctx.lineTo(size - 12, 6);
                    ctx.stroke();
                });
            }
            if (name === 'chest' || name === 'ender chest') {
                return makeCanvasTexture(seed, (ctx, size, rng) => {
                    const woodBase = name === 'ender chest' ? 0x3e2a58 : 0x8b5a2b;
                    paintPlanks(ctx, size, rng, woodBase);
                    ctx.fillStyle = name === 'ender chest' ? 'rgba(70,220,140,0.6)' : 'rgba(210,170,80,0.7)';
                    ctx.fillRect(Math.floor(size * 0.42), Math.floor(size * 0.42), Math.floor(size * 0.16), Math.floor(size * 0.2));
                    ctx.strokeStyle = 'rgba(30,20,15,0.6)';
                    ctx.strokeRect(2, 2, size - 4, size - 4);
                });
            }

            if (name.includes('coal')) return makeCanvasTexture(seed, (ctx, size, rng) => paintOre(ctx, size, rng, 0x1d1d1d));
            if (name.includes('iron')) return makeCanvasTexture(seed, (ctx, size, rng) => paintOre(ctx, size, rng, 0xb0b0b0));
            if (name.includes('copper')) return makeCanvasTexture(seed, (ctx, size, rng) => paintOre(ctx, size, rng, 0xb87333));
            if (name.includes('gold')) return makeCanvasTexture(seed, (ctx, size, rng) => paintNoise(ctx, size, rng, 0xd6b640, 200, 1, 3, 0.8, 1.35));
            if (name.includes('diamond')) return makeCanvasTexture(seed, (ctx, size, rng) => paintOre(ctx, size, rng, 0x55ffff));
            if (name.includes('emerald')) return makeCanvasTexture(seed, (ctx, size, rng) => paintOre(ctx, size, rng, 0x00c774));
            if (name.includes('ruby')) return makeCanvasTexture(seed, (ctx, size, rng) => paintOre(ctx, size, rng, 0xd1002c));

            return makeCanvasTexture(seed, (ctx, size, rng) => paintNoise(ctx, size, rng, block.color || 0x999999, 200, 1, 3, 0.8, 1.25));
        }

        function createTexturedMaterial(type, faceKey = 'side') {
            const texture = createFaceTexture(type, faceKey);
            const block = BLOCK_TYPES[type] || BLOCK_TYPES[0];
            const name = (block.name || '').toLowerCase();
            const materialOptions = { map: texture, color: 0xffffff };
            if (name === 'glass') {
                materialOptions.transparent = true;
                materialOptions.opacity = 0.45;
                materialOptions.side = THREE.DoubleSide;
                materialOptions.shininess = 100;
                materialOptions.specular = new THREE.Color(0x99ddff);
            } else if (name === 'ice') {
                materialOptions.transparent = true;
                materialOptions.opacity = 0.78;
                materialOptions.shininess = 80;
                materialOptions.specular = new THREE.Color(0xbde8ff);
            }
            return new THREE.MeshPhongMaterial(materialOptions);
        }

        function getMaterialForBlockType(type) {
            const resolvedType = (typeof type === 'number' && type >= 0 && type < BLOCK_TYPES.length) ? type : 0;
            if (blockMaterialCache.has(resolvedType)) return blockMaterialCache.get(resolvedType);
            const blockName = (BLOCK_TYPES[resolvedType].name || '').toLowerCase();
            let material;
            if (blockName === 'grass' || blockName === 'wood' || blockName === 'crafting table') {
                const side = createTexturedMaterial(resolvedType, 'side');
                const top = createTexturedMaterial(resolvedType, 'top');
                const bottom = createTexturedMaterial(resolvedType, 'bottom');
                material = [side, side, top, bottom, side, side];
            } else {
                material = createTexturedMaterial(resolvedType, 'side');
            }
            blockMaterialCache.set(resolvedType, material);
            return material;
        }

        function getGroundMaterial() {
            return new THREE.MeshPhongMaterial({
                map: makeCanvasTexture('ground:grass', (ctx, size, rng) => {
                    paintNoise(ctx, size, rng, 0x3f8f2a, 220, 1, 3, 0.75, 1.3);
                    for (let i = 0; i < 28; i++) {
                        const x = Math.floor(rng() * size);
                        const y = Math.floor(rng() * size);
                        ctx.fillStyle = 'rgba(90, 50, 20, 0.2)';
                        ctx.fillRect(x, y, 2 + Math.floor(rng() * 4), 2 + Math.floor(rng() * 4));
                    }
                }),
                side: THREE.DoubleSide
            });
        }
        
        // Controls configuration
        const defaultControls = {
            forward: 'w',
            backward: 's',
            left: 'a',
            right: 'd',
            jump: ' ',
            toggle_chat: 't',
            toggle_fly: 'f',
            toggle_inventory: '`',
            open_settings: 'p',
            open_crafting: 'c',
            interact: 'e',
            drop_item: 'q',
            open_mods: 'm',
            open_armor: 'h',
            sprint: 'r',
            voice_chat: 'v',
            mouse_button_4: 'unbound',
            mouse_button_5: 'unbound'
        };
        let controls = { ...defaultControls };
        // Mouse button actions
        let mouseButtonActions = {
            m4: 'unbound',
            m5: 'unbound'
        };
        
                const availableActions = [
            { id: 'unbound', label: 'Unbound' },
            { id: 'place_block', label: 'Place Block' },
            { id: 'remove_block', label: 'Remove Block' },
            { id: 'toggle_fly', label: 'Toggle Fly Mode' },
            { id: 'toggle_inventory', label: 'Toggle Inventory' },
            { id: 'toggle_crafting', label: 'Open Crafting' },
            { id: 'interact', label: 'Interact' },
            { id: 'drop_item', label: 'Drop Selected Item' },
            { id: 'open_mods', label: 'Open Mods Menu' },
            { id: 'open_armor', label: 'Open Armor' },
            { id: 'voice_chat', label: 'Push To Talk' }
        ];

        const CRAFTING_RECIPES = [
            {
                id: 'crafting_table',
                name: 'Crafting Table',
                output: { type: CRAFTING_TABLE_TYPE, count: 1 },
                ingredients: [
                    { type: 2, count: 4 }
                ],
                grid: [2, 2, null, 2, 2, null, null, null, null],
                requiresTable: false
            },
            {
                id: 'glass',
                name: 'Glass',
                output: { type: GLASS_TYPE, count: 4 },
                ingredients: [
                    { type: 4, count: 4 }
                ],
                grid: [4, 4, null, 4, 4, null, null, null, null],
                requiresTable: true
            },
            {
                id: 'stone_bricks',
                name: 'Stone Bricks',
                output: { type: STONE_BRICKS_TYPE, count: 4 },
                ingredients: [
                    { type: 1, count: 4 }
                ],
                grid: [1, 1, null, 1, 1, null, null, null, null],
                requiresTable: true
            }
        ];
        CRAFTING_RECIPES.push({
            id: 'chest',
            name: 'Chest',
            output: { type: CHEST_TYPE, count: 1 },
            ingredients: [
                { type: 2, count: 6 },
                { type: 1, count: 2 }
            ],
            grid: [2, 2, 2, 2, null, 2, 1, 1, null],
            requiresTable: true
        });
        CRAFTING_RECIPES.push(
            {
                id: 'ender_chest',
                name: 'Ender Chest',
                output: { type: ENDER_CHEST_TYPE, count: 1 },
                ingredients: [{ type: 9, count: 6 }, { type: 8, count: 2 }],
                grid: [9, 9, 9, 9, 8, 9, 9, 9, null],
                requiresTable: true
            },
            {
                id: 'copper_refine',
                name: 'Copper',
                output: { type: COPPER_TYPE, count: 2 },
                ingredients: [{ type: 1, count: 2 }, { type: 4, count: 1 }],
                grid: [1, 1, null, 4, null, null, null, null, null],
                requiresTable: true
            },
            {
                id: 'coal_compact',
                name: 'Coal',
                output: { type: COAL_TYPE, count: 2 },
                ingredients: [{ type: 5, count: 2 }, { type: 9, count: 1 }],
                grid: [5, 5, null, 9, null, null, null, null, null],
                requiresTable: true
            },
            {
                id: 'iron_refine',
                name: 'Iron',
                output: { type: IRON_TYPE, count: 2 },
                ingredients: [{ type: 12, count: 2 }, { type: COAL_TYPE, count: 1 }],
                grid: [12, 12, null, COAL_TYPE, null, null, null, null, null],
                requiresTable: true
            },
            {
                id: 'emerald_mix',
                name: 'Emerald',
                output: { type: EMERALD_TYPE, count: 1 },
                ingredients: [{ type: 8, count: 1 }, { type: COPPER_TYPE, count: 2 }],
                grid: [8, null, null, COPPER_TYPE, COPPER_TYPE, null, null, null, null],
                requiresTable: true
            },
            {
                id: 'ruby_mix',
                name: 'Ruby',
                output: { type: RUBY_TYPE, count: 1 },
                ingredients: [{ type: 3, count: 2 }, { type: 7, count: 1 }],
                grid: [3, 3, null, 7, null, null, null, null, null],
                requiresTable: true
            },
            {
                id: 'armor_helmet',
                name: 'Iron Helmet',
                output: { kind: 'armor', armorPiece: 'helmet', count: 1, emoji: '[H]' },
                ingredients: [{ type: IRON_TYPE, count: 5 }],
                grid: [IRON_TYPE, IRON_TYPE, IRON_TYPE, IRON_TYPE, null, IRON_TYPE, null, null, null],
                requiresTable: true
            },
            {
                id: 'armor_chestplate',
                name: 'Iron Chestplate',
                output: { kind: 'armor', armorPiece: 'chestplate', count: 1, emoji: '[C]' },
                ingredients: [{ type: IRON_TYPE, count: 8 }],
                grid: [IRON_TYPE, null, IRON_TYPE, IRON_TYPE, IRON_TYPE, IRON_TYPE, IRON_TYPE, IRON_TYPE, IRON_TYPE],
                requiresTable: true
            },
            {
                id: 'armor_leggings',
                name: 'Iron Leggings',
                output: { kind: 'armor', armorPiece: 'leggings', count: 1, emoji: '[L]' },
                ingredients: [{ type: IRON_TYPE, count: 7 }],
                grid: [IRON_TYPE, IRON_TYPE, IRON_TYPE, IRON_TYPE, null, IRON_TYPE, IRON_TYPE, null, IRON_TYPE],
                requiresTable: true
            },
            {
                id: 'armor_boots',
                name: 'Iron Boots',
                output: { kind: 'armor', armorPiece: 'boots', count: 1, emoji: '[B]' },
                ingredients: [{ type: IRON_TYPE, count: 4 }],
                grid: [IRON_TYPE, null, IRON_TYPE, IRON_TYPE, null, IRON_TYPE, null, null, null],
                requiresTable: true
            }
        );

        function saveControlsToLocalStorage() {
            try {
                const payload = {
                    controls: controls,
                    mouseButtonActions: mouseButtonActions,
                    mouseSensitivity: mouseSensitivity,
                    screenScale: screenScale,
                    renderScale: renderScale,
                    mobileModeEnabled: mobileModeEnabled
                };
                localStorage.setItem('miniblox_controls', JSON.stringify(payload));
            } catch (e) {
                console.warn('Could not save controls:', e);
            }
        }

        function loadControlsFromLocalStorage() {
            try {
                const saved = localStorage.getItem('miniblox_controls');
                if (!saved) return;
                const data = JSON.parse(saved);
                if (data && typeof data === 'object') {
                    if (data.controls && typeof data.controls === 'object') {
                        controls = { ...defaultControls, ...data.controls };
                    } else {
                        controls = { ...defaultControls };
                    }
                    if (data.mouseButtonActions && typeof data.mouseButtonActions === 'object') {
                        mouseButtonActions = { ...mouseButtonActions, ...data.mouseButtonActions };
                    }
                    if (typeof data.mouseSensitivity === 'number') {
                        mouseSensitivity = data.mouseSensitivity;
                    }
                    if (typeof data.screenScale === 'number') {
                        screenScale = Math.max(0.6, Math.min(1, data.screenScale));
                    }
                    if (typeof data.renderScale === 'number') {
                        renderScale = Math.max(0.5, Math.min(1, data.renderScale));
                    }
                    if (typeof data.mobileModeEnabled === 'boolean') {
                        mobileModeEnabled = data.mobileModeEnabled;
                    }
                }
            } catch (e) {
                console.warn('Could not load controls:', e);
            }
        }

        function formatPercent(value) {
            return `${Math.round(value * 100)}%`;
        }

        function applyMobileModeUI() {
            document.body.classList.toggle('mobile-mode', mobileModeEnabled);
            const controlsInfo = document.getElementById('controls-info');
            const mobileControls = document.getElementById('mobile-controls');
            if (controlsInfo && mobileModeEnabled) {
                controlsInfo.style.display = 'none';
            }
            if (mobileControls) {
                mobileControls.style.display = (mobileModeEnabled && !isMenuOpen()) ? 'block' : 'none';
            }
        }

        function applyRendererSizing() {
            if (!renderer || !camera) return;
            const viewportWidth = Math.max(1, window.innerWidth);
            const viewportHeight = Math.max(1, window.innerHeight);
            const drawWidth = Math.max(1, Math.floor(viewportWidth * screenScale));
            const drawHeight = Math.max(1, Math.floor(viewportHeight * screenScale));
            renderer.setPixelRatio(Math.max(0.5, Math.min(2, window.devicePixelRatio * renderScale)));
            renderer.setSize(drawWidth, drawHeight, false);
            renderer.domElement.style.position = 'fixed';
            renderer.domElement.style.left = `${Math.floor((viewportWidth - drawWidth) / 2)}px`;
            renderer.domElement.style.top = `${Math.floor((viewportHeight - drawHeight) / 2)}px`;
            renderer.domElement.style.width = `${drawWidth}px`;
            renderer.domElement.style.height = `${drawHeight}px`;
            camera.aspect = drawWidth / drawHeight;
            camera.updateProjectionMatrix();
        }

        function updateScreenScale(value) {
            const parsed = parseFloat(value);
            if (Number.isNaN(parsed)) return;
            screenScale = Math.max(0.6, Math.min(1, parsed));
            const label = document.getElementById('screen-size-value');
            if (label) label.textContent = formatPercent(screenScale);
            applyRendererSizing();
            saveControlsToLocalStorage();
        }

        function updateRenderScale(value) {
            const parsed = parseFloat(value);
            if (Number.isNaN(parsed)) return;
            renderScale = Math.max(0.5, Math.min(1, parsed));
            const label = document.getElementById('render-scale-value');
            if (label) label.textContent = formatPercent(renderScale);
            applyRendererSizing();
            saveControlsToLocalStorage();
        }

        function setMobileMode(enabled) {
            mobileModeEnabled = !!enabled;
            mobileInputState.moveX = 0;
            mobileInputState.moveY = 0;
            mobileInputState.jump = false;
            mobileTouchState.lookId = null;
            mobileTouchState.joystickId = null;
            applyMobileModeUI();
            applyRendererSizing();
            saveControlsToLocalStorage();
        }

        function toggleFullscreenMode() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else {
                document.exitFullscreen().catch(() => {});
            }
        }

        function setupMobileControls() {
            const joystickZone = document.getElementById('mobile-joystick-zone');
            const joystickBase = document.getElementById('mobile-joystick-base');
            const joystickKnob = document.getElementById('mobile-joystick-knob');
            const jumpBtn = document.getElementById('mobile-jump-btn');
            const breakBtn = document.getElementById('mobile-break-btn');
            const placeBtn = document.getElementById('mobile-place-btn');
            const interactBtn = document.getElementById('mobile-interact-btn');
            const inventoryBtn = document.getElementById('mobile-inventory-btn');
            const settingsBtn = document.getElementById('mobile-settings-btn');
            if (!joystickZone || !joystickBase || !joystickKnob) return;

            const updateStickFromPoint = (clientX, clientY) => {
                const rect = joystickBase.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                const dx = clientX - cx;
                const dy = clientY - cy;
                const radius = rect.width * 0.34;
                const dist = Math.hypot(dx, dy);
                const limited = dist > radius ? radius / dist : 1;
                const px = dx * limited;
                const py = dy * limited;
                mobileInputState.moveX = Math.max(-1, Math.min(1, px / radius));
                mobileInputState.moveY = Math.max(-1, Math.min(1, py / radius));
                joystickKnob.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px))`;
            };

            const resetStick = () => {
                mobileInputState.moveX = 0;
                mobileInputState.moveY = 0;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            };

            joystickZone.addEventListener('pointerdown', (event) => {
                if (!mobileModeEnabled) return;
                event.preventDefault();
                mobileTouchState.joystickId = event.pointerId;
                joystickZone.setPointerCapture(event.pointerId);
                updateStickFromPoint(event.clientX, event.clientY);
            });

            joystickZone.addEventListener('pointermove', (event) => {
                if (mobileTouchState.joystickId !== event.pointerId) return;
                event.preventDefault();
                updateStickFromPoint(event.clientX, event.clientY);
            });

            const releaseJoystick = (event) => {
                if (mobileTouchState.joystickId !== event.pointerId) return;
                mobileTouchState.joystickId = null;
                resetStick();
            };
            joystickZone.addEventListener('pointerup', releaseJoystick);
            joystickZone.addEventListener('pointercancel', releaseJoystick);

            const holdJumpStart = (event) => {
                if (!mobileModeEnabled) return;
                event.preventDefault();
                mobileInputState.jump = true;
            };
            const holdJumpStop = (event) => {
                event.preventDefault();
                mobileInputState.jump = false;
            };
            jumpBtn.addEventListener('pointerdown', holdJumpStart);
            jumpBtn.addEventListener('pointerup', holdJumpStop);
            jumpBtn.addEventListener('pointercancel', holdJumpStop);
            jumpBtn.addEventListener('pointerleave', holdJumpStop);

            breakBtn.addEventListener('pointerdown', (event) => { event.preventDefault(); if (!isOverlayOpen()) placeOrRemoveBlock(true); });
            placeBtn.addEventListener('pointerdown', (event) => { event.preventDefault(); if (!isOverlayOpen()) placeOrRemoveBlock(false); });
            interactBtn.addEventListener('pointerdown', (event) => { event.preventDefault(); if (!isOverlayOpen()) interactWithTargetedObject(); });
            inventoryBtn.addEventListener('pointerdown', (event) => { event.preventDefault(); toggleInventory(); });
            settingsBtn.addEventListener('pointerdown', (event) => { event.preventDefault(); toggleQuickMenu(true); });

            renderer.domElement.addEventListener('pointerdown', (event) => {
                if (!mobileModeEnabled || event.pointerType !== 'touch') return;
                if (event.target && event.target.closest && event.target.closest('#mobile-controls')) return;
                if (isMenuOpen() || isOverlayOpen()) return;
                if (event.clientX < window.innerWidth * 0.5) return;
                mobileTouchState.lookId = event.pointerId;
                mobileTouchState.lookLastX = event.clientX;
                mobileTouchState.lookLastY = event.clientY;
                renderer.domElement.setPointerCapture(event.pointerId);
            });

            renderer.domElement.addEventListener('pointermove', (event) => {
                if (mobileTouchState.lookId !== event.pointerId) return;
                event.preventDefault();
                const deltaX = event.clientX - mobileTouchState.lookLastX;
                const deltaY = event.clientY - mobileTouchState.lookLastY;
                mobileTouchState.lookLastX = event.clientX;
                mobileTouchState.lookLastY = event.clientY;
                yaw -= deltaX * mouseSensitivity * 1.5;
                pitch -= deltaY * mouseSensitivity * 1.5;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            });

            const releaseLook = (event) => {
                if (mobileTouchState.lookId !== event.pointerId) return;
                mobileTouchState.lookId = null;
            };
            renderer.domElement.addEventListener('pointerup', releaseLook);
            renderer.domElement.addEventListener('pointercancel', releaseLook);

            applyMobileModeUI();
        }
        
        let recordingControl = null;
        let m4m5WarningShown = false; // Track if warning has been shown
        
        let myPlayer = { 
            x: 0, y: 10, z: 0, 
            velocity: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0 },
            isGrounded: false,
            isFlying: false,
            health: 100
        };
        
        let pitch = 0;
        let yaw = 0;
        let lastAutoSaveTime = 0;
        const AUTO_SAVE_INTERVAL = 15000; // Save every 15 seconds
        
        // ================= LOADING SCREEN =================
        function updateLoadingProgress(percent, text) {
            document.getElementById('loading-progress').style.width = percent + '%';
            if (text) {
                document.getElementById('loading-text').textContent = text;
            }
        }
        
        // ================= SAVE STATUS DISPLAY =================
        function showSaveStatus(status = 'Saving...') {
            const saveStatusEl = document.getElementById('save-status');
            const statusText = document.getElementById('save-status-text');
            
            statusText.textContent = status;
            saveStatusEl.style.display = 'block';
            saveStatusEl.style.animation = 'none';
            
            // Trigger animation
            setTimeout(() => {
                saveStatusEl.style.animation = 'fadeInOut 0.6s ease-in-out';
            }, 10);
            
            // Hide after animation
            setTimeout(() => {
                saveStatusEl.style.display = 'none';
            }, 600);
        }
        
        // ================= AUTO-SAVE SYSTEM =================
        function saveGameToLocalStorage() {
            const gameState = {
                player: {
                    x: myPlayer.x,
                    y: myPlayer.y,
                    z: myPlayer.z,
                    health: myPlayer.health,
                    isFlying: myPlayer.isFlying
                },
                gameMode: currentGameMode,
                blocks: blocks.map(block => ({
                    x: block.position.x,
                    y: block.position.y,
                    z: block.position.z,
                    type: block.userData.type
                })),
                villagers: villagers.map(v => ({
                    id: v.id,
                    name: v.name,
                    x: v.mesh.position.x,
                    y: v.mesh.position.y,
                    z: v.mesh.position.z
                })),
                currentBlockType: currentBlockType,
                hotbarSlots: hotbarSlots,
                removedMaterials: Array.from(removedMaterials),
                inventoryCounts: inventoryCounts,
                chestInventories: chestInventories,
                enderChestInventory: enderChestInventory,
                armorSlots: armorSlots,
                armorInventory: armorInventory,
                saveTime: new Date().toLocaleString()
            };
            
            try {
                localStorage.setItem('miniblox_autosave', JSON.stringify(gameState));
                const now = new Date();
                const timeStr = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
                document.getElementById('last-save-time').textContent = timeStr;
                
                // Show save status
                showSaveStatus('üíæ Saved');
                
                // Also save to current world if one is loaded
                if (currentWorldId !== null) {
                    saveWorldById(currentWorldId);
                }
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
        }
        
        function loadGameFromLocalStorage() {
            try {
                const saved = localStorage.getItem('miniblox_autosave');
                if (!saved) return false;
                
                const gameState = JSON.parse(saved);
                
                // Restore player state
                myPlayer.x = gameState.player.x;
                myPlayer.y = gameState.player.y;
                myPlayer.z = gameState.player.z;
                myPlayer.health = gameState.player.health;
                myPlayer.isFlying = gameState.player.isFlying;
                currentGameMode = gameState.gameMode || 'survival';
                
                // Restore blocks
                activeChestKey = null;
                gameState.blocks.forEach(blockData => {
                    createBlockAt(blockData.x, blockData.y, blockData.z, blockData.type);
                });
                villagers.forEach(v => scene.remove(v.mesh));
                villagers = [];
                (gameState.villagers || []).forEach(v => spawnVillagerAt(v.x, v.y, v.z, v.name));
                
                // Restore other state
                currentBlockType = gameState.currentBlockType;
                inventoryCounts = gameState.gameMode === 'creative' && !gameState.inventoryCounts
                    ? BLOCK_TYPES.map(() => MAX_STACK)
                    : normalizeInventoryCounts(gameState.inventoryCounts);
                hotbarSlots = ensureHotbarSlots(gameState.hotbarSlots);
                removedMaterials = new Set(gameState.removedMaterials || []);
                chestInventories = gameState.chestInventories || {};
                enderChestInventory = normalizeStorageCounts(gameState.enderChestInventory || []);
                armorSlots = gameState.armorSlots || { helmet: null, chestplate: null, leggings: null, boots: null };
                armorInventory = gameState.armorInventory || { helmet: 0, chestplate: 0, leggings: 0, boots: 0 };
                reconcileRemovedMaterials();
                renderInventoryUI();
                updateGameModeUI();
                selectBlockType(currentBlockType);
                
                // Update UI
                document.getElementById('health').textContent = Math.max(0, Math.floor(myPlayer.health));
                const healthPercentage = Math.max(0, Math.min(100, myPlayer.health));
                document.getElementById('health-fill').style.width = healthPercentage + '%';
                
                addChatMessage('Auto-save loaded! Last saved: ' + gameState.saveTime);
                return true;
            } catch (e) {
                console.warn('Could not load from localStorage:', e);
                return false;
            }
        }
        
        // ================= MENU SYSTEM =================
        let currentWorldSlot = null;
        let currentWorldId = null;
        let renamingSlotIndex = null;
        
        function startMultiplayer() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('unavailable-message').style.display = 'flex';
            applyMobileModeUI();
            
            let countdown = 10;
            const countdownElement = document.getElementById('countdown-timer');
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    document.getElementById('unavailable-message').style.display = 'none';
                    document.getElementById('main-menu').style.display = 'flex';
                    applyMobileModeUI();
                } else {
                    countdownElement.textContent = `Returning to menu in ${countdown} seconds...`;
                }
            }, 1000);
        }
        
        function startSingleplayer() {
            document.getElementById('corner-settings-btn').style.display = 'none';
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('world-slots').style.display = 'flex';
            applyMobileModeUI();
            renderWorldSlots();
        }
        
        function createNewWorld() {
            // Find first empty slot
            for (let i = 0; i < 10; i++) {
                const slotData = getWorldSlotData(i);
                if (!slotData.blocks || slotData.blocks.length === 0) {
                    loadWorld(i);
                    return;
                }
            }
            alert('All world slots are full! Delete a world first.');
        }
        
        function backToMainMenu() {
            document.getElementById('corner-settings-btn').style.display = 'none';
            document.getElementById('world-slots').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            applyMobileModeUI();
        }
        
        function renderWorldSlots() {
            const slotsGrid = document.getElementById('slots-grid');
            slotsGrid.innerHTML = '';
            
            try {
                const worldIndex = JSON.parse(localStorage.getItem('miniblox_world_index') || '[]');
                
                const userWorlds = worldIndex;
                
                if (userWorlds.length === 0) {
                    slotsGrid.innerHTML = '<div style="color: #888; text-align: center; padding: 40px; grid-column: 1/-1;">No worlds created yet. Click "Create World" to get started!</div>';
                    return;
                }
                
                userWorlds.forEach(worldMeta => {
                    const worldData = JSON.parse(localStorage.getItem(`miniblox_world_${worldMeta.id}`));
                    if (worldData) {
                        const slotElement = document.createElement('div');
                        slotElement.className = 'world-slot';
                        
                        const blockCount = worldData.blocks ? worldData.blocks.length : 0;
                        const saveTime = worldData.saveTime || 'Never';
                        
                        slotElement.innerHTML = `
                            <div class="world-slot-title">üåç ${worldData.name}</div>
                            <div class="world-slot-info">Blocks: ${blockCount}</div>
                            <div class="world-slot-info">Last Played: ${saveTime}</div>
                            <div class="world-slot-buttons">
                                <button class="slot-button" onclick="loadWorldById('${worldMeta.id}')">‚ñ∂Ô∏è Load</button>
                                <button class="slot-button" onclick="renameWorld('${worldMeta.id}')">‚úèÔ∏è Rename</button>
                                <button class="slot-button delete" onclick="deleteWorld('${worldMeta.id}')">üóëÔ∏è Delete</button>
                            </div>
                        `;
                        
                        slotsGrid.appendChild(slotElement);
                    }
                });
            } catch (e) {
                console.warn('Could not render world slots:', e);
            }
        }
        
        function getWorldSlotData(slotIndex) {
            try {
                const saved = localStorage.getItem(`miniblox_world_${slotIndex}`);
                if (!saved) return { blocks: null };
                return JSON.parse(saved);
            } catch (e) {
                return { blocks: null };
            }
        }
        
        function saveWorldToSlot(slotIndex) {
            // This function is now obsolete but kept for compatibility
            if (currentWorldId) {
                saveWorldById(currentWorldId);
            }
        }
        
        function saveWorldById(worldId) {
            const worldData = JSON.parse(localStorage.getItem(`miniblox_world_${worldId}`)) || {};
            
            worldData.saveTime = new Date().toLocaleString();
            worldData.player = {
                x: myPlayer.x,
                y: myPlayer.y,
                z: myPlayer.z,
                health: myPlayer.health,
                isFlying: myPlayer.isFlying
            };
            worldData.gameMode = currentGameMode;
            worldData.blocks = blocks.map(block => ({
                x: block.position.x,
                y: block.position.y,
                z: block.position.z,
                type: block.userData.type
            }));
            worldData.villagers = villagers.map(v => ({
                id: v.id,
                name: v.name,
                x: v.mesh.position.x,
                y: v.mesh.position.y,
                z: v.mesh.position.z
            }));
            worldData.currentBlockType = currentBlockType;
            worldData.hotbarSlots = hotbarSlots;
            worldData.removedMaterials = Array.from(removedMaterials);
            worldData.inventoryCounts = inventoryCounts;
            worldData.chestInventories = chestInventories;
            worldData.enderChestInventory = enderChestInventory;
            worldData.armorSlots = armorSlots;
            worldData.armorInventory = armorInventory;
            
            try {
                localStorage.setItem(`miniblox_world_${worldId}`, JSON.stringify(worldData));
            } catch (e) {
                console.warn('Could not save world:', e);
            }
        }
        
        function loadWorldById(worldId) {
            currentWorldId = worldId;
            
            try {
                const worldData = JSON.parse(localStorage.getItem(`miniblox_world_${worldId}`));
                if (!worldData) {
                    addChatMessage('Error loading world!');
                    return;
                }
                
                // Load player state
                myPlayer.x = worldData.player.x;
                myPlayer.y = worldData.player.y;
                myPlayer.z = worldData.player.z;
                myPlayer.health = worldData.player.health;
                myPlayer.isFlying = worldData.player.isFlying;
                currentGameMode = worldData.gameMode || 'survival';
                
                // Clear existing blocks
                blocks.forEach(block => scene.remove(block));
                blocks = [];
                activeChestKey = null;
                document.getElementById('chest-menu').style.display = 'none';
                // Load blocks
                if (worldData.blocks && worldData.blocks.length > 0) {
                    worldData.blocks.forEach(blockData => {
                        createBlockAt(blockData.x, blockData.y, blockData.z, blockData.type);
                    });
                    addChatMessage(`Loaded world: ${worldData.name}`);
                } else {
                    addChatMessage(`Starting new world: ${worldData.name}`);
                }
                
                currentBlockType = worldData.currentBlockType || 0;
                inventoryCounts = worldData.gameMode === 'creative' && !worldData.inventoryCounts
                    ? BLOCK_TYPES.map(() => MAX_STACK)
                    : normalizeInventoryCounts(worldData.inventoryCounts);
                hotbarSlots = ensureHotbarSlots(worldData.hotbarSlots);
                removedMaterials = new Set(worldData.removedMaterials || []);
                chestInventories = worldData.chestInventories || {};
                enderChestInventory = normalizeStorageCounts(worldData.enderChestInventory || []);
                armorSlots = worldData.armorSlots || { helmet: null, chestplate: null, leggings: null, boots: null };
                armorInventory = worldData.armorInventory || { helmet: 0, chestplate: 0, leggings: 0, boots: 0 };
                villagers.forEach(v => scene.remove(v.mesh));
                villagers = [];
                (worldData.villagers || []).forEach(v => spawnVillagerAt(v.x, v.y, v.z, v.name));
                reconcileRemovedMaterials();
                renderInventoryUI();
                updateGameModeUI();
                selectBlockType(currentBlockType);
                
                document.getElementById('health').textContent = Math.max(0, Math.floor(myPlayer.health));
                const healthPercentage = Math.max(0, Math.min(100, myPlayer.health));
                document.getElementById('health-fill').style.width = healthPercentage + '%';
                
                // Hide menu and start game
                document.getElementById('world-slots').style.display = 'none';
                startGameFromMenu();
            } catch (e) {
                console.error('Error loading world:', e);
                addChatMessage('Error loading world!');
            }
        }
        
        function deleteWorld(worldId) {
            if (confirm('Delete this world? This cannot be undone!')) {
                try {
                    localStorage.removeItem(`miniblox_world_${worldId}`);
                    let worldIndex = JSON.parse(localStorage.getItem('miniblox_world_index') || '[]');
                    worldIndex = worldIndex.filter(w => w.id !== worldId);
                    localStorage.setItem('miniblox_world_index', JSON.stringify(worldIndex));
                    addChatMessage('World deleted.');
                    renderWorldSlots();
                } catch (e) {
                    console.warn('Could not delete world:', e);
                }
            }
        }
        
        function renameWorld(worldId) {
            const worldData = JSON.parse(localStorage.getItem(`miniblox_world_${worldId}`));
            if (!worldData) return;
            
            const newName = prompt('Enter new world name:', worldData.name);
            if (newName && newName.trim()) {
                try {
                    worldData.name = newName.trim();
                    localStorage.setItem(`miniblox_world_${worldId}`, JSON.stringify(worldData));
                    
                    let worldIndex = JSON.parse(localStorage.getItem('miniblox_world_index') || '[]');
                    const worldMeta = worldIndex.find(w => w.id === worldId);
                    if (worldMeta) {
                        worldMeta.name = newName.trim();
                        localStorage.setItem('miniblox_world_index', JSON.stringify(worldIndex));
                    }
                    
                    renderWorldSlots();
                } catch (e) {
                    console.warn('Could not rename world:', e);
                }
            }
        }
        
        function openCreateWorldDialog() {
            document.getElementById('create-world-input').value = '';
            document.getElementById('create-world-mode').value = 'survival';
            document.getElementById('create-world-villagers').checked = true;
            document.getElementById('create-world-dialog').style.display = 'flex';
            document.getElementById('create-world-input').focus();
        }
        
        function confirmCreateWorld() {
            const worldName = document.getElementById('create-world-input').value.trim();
            const addStructures = document.getElementById('create-world-structures').checked;
            const gameMode = document.getElementById('create-world-mode').value;
            const addVillagers = document.getElementById('create-world-villagers').checked;
            
            if (!worldName) {
                alert('Please enter a world name!');
                return;
            }
            
            const worldId = `world_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            try {
                const blocks = [];
                // Generate structures if enabled
                if (addStructures) {
                    // Add some starter blocks
                    for (let i = 0; i < 20; i++) {
                        const x = Math.floor((Math.random() - 0.5) * 20);
                        const z = Math.floor((Math.random() - 0.5) * 20);
                        const type = Math.floor(Math.random() * BLOCK_TYPES.length);
                        blocks.push({ x, y: 1, z, type });
                    }
                    
                    // Create a simple house
                    for (let x = -3; x <= 3; x++) {
                        for (let z = -3; z <= 3; z++) {
                            blocks.push({ x, y: 0, z, type: 1 });
                        }
                    }
                    
                    // Walls
                    for (let y = 1; y <= 3; y++) {
                        for (let x = -3; x <= 3; x++) {
                            blocks.push({ x, y, z: -3, type: 2 });
                            blocks.push({ x, y, z: 3, type: 2 });
                            if (x < -1 || x > 1) {
                                blocks.push({ x: -3, y, z: x, type: 2 });
                                blocks.push({ x: 3, y, z: x, type: 2 });
                            }
                        }
                    }
                    
                    // Roof
                    for (let x = -3; x <= 3; x++) {
                        for (let z = -3; z <= 3; z++) {
                            blocks.push({ x, y: 4, z, type: 3 });
                        }
                    }
                }
                
                const worldData = {
                    id: worldId,
                    userId: LOCAL_USER_ID,
                    name: worldName,
                    saveTime: new Date().toLocaleString(),
                    gameMode: gameMode,
                    player: {
                        x: 0,
                        y: 10,
                        z: 0,
                        health: 100,
                        isFlying: gameMode === 'creative'
                    },
                    blocks: blocks,
                    villagers: addVillagers ? [
                        { id: 'v0', name: 'Villager 1', x: 3, y: 1, z: 3 },
                        { id: 'v1', name: 'Villager 2', x: -2, y: 1, z: 4 },
                        { id: 'v2', name: 'Villager 3', x: 4, y: 1, z: -2 }
                    ] : [],
                    currentBlockType: 0,
                    hotbarSlots: [0, 1, 2, 3, 4, 5, 6, 7, 8],
                    removedMaterials: [],
                    inventoryCounts: gameMode === 'creative' ? BLOCK_TYPES.map(() => MAX_STACK) : normalizeInventoryCounts(),
                    chestInventories: {},
                    enderChestInventory: BLOCK_TYPES.map(() => 0),
                    armorSlots: { helmet: null, chestplate: null, leggings: null, boots: null },
                    armorInventory: { helmet: 0, chestplate: 0, leggings: 0, boots: 0 }
                };
                
                localStorage.setItem(`miniblox_world_${worldId}`, JSON.stringify(worldData));
                
                // Update world index
                let worldIndex = JSON.parse(localStorage.getItem('miniblox_world_index') || '[]');
                worldIndex.push({ id: worldId, userId: LOCAL_USER_ID, name: worldName });
                localStorage.setItem('miniblox_world_index', JSON.stringify(worldIndex));
                
                document.getElementById('create-world-dialog').style.display = 'none';
                loadWorldById(worldId);
            } catch (e) {
                console.warn('Could not create world:', e);
                alert('Error creating world!');
            }
        }
        
        function cancelCreateWorld() {
            document.getElementById('create-world-dialog').style.display = 'none';
            document.getElementById('create-world-input').value = '';
            document.getElementById('create-world-structures').checked = false;
            document.getElementById('create-world-villagers').checked = true;
            document.getElementById('create-world-mode').value = 'survival';
        }
        
        function startGameFromMenu() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('world-slots').style.display = 'none';
            document.getElementById('rename-dialog').style.display = 'none';
            document.getElementById('loading').style.display = 'none';
            document.getElementById('quick-menu').style.display = 'none';
            document.getElementById('chest-menu').style.display = 'none';
            document.getElementById('mods-menu').style.display = 'none';
            document.getElementById('inventory').style.display = 'none';
            document.getElementById('crafting').style.display = 'none';
            document.getElementById('settings').style.display = 'none';
            document.getElementById('inventory-trash').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('health-bar').style.display = 'block';
            document.getElementById('chat').style.display = 'block';
            document.getElementById('controls-info').style.display = 'none';
            document.getElementById('corner-settings-btn').style.display = 'block';
            applyMobileModeUI();
            updateGameModeUI();
            renderArmorUI();
        }
        
        // ================= INITIALIZATION =================
        function init() {
            console.log("Starting game initialization...");
            
            try {
                // Create scene
                updateLoadingProgress(10, 'Creating scene...');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                
                // Create camera (FIRST PERSON)
                updateLoadingProgress(20, 'Setting up camera...');
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.7, 0); // Eye level
                
                // Create renderer
                updateLoadingProgress(30, 'Initializing renderer...');
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
                applyRendererSizing();
                setupMobileControls();
                
                // Add lights
                updateLoadingProgress(40, 'Setting up lighting...');
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Create simple world
                updateLoadingProgress(60, 'Building world...');
                createWorld();
                
                // Try to load auto-save
                updateLoadingProgress(70, 'Loading save data...');
                const hasAutoSave = loadGameFromLocalStorage();
                
                // Setup event listeners
                updateLoadingProgress(90, 'Setting up controls...');
                loadControlsFromLocalStorage();
                applyMobileModeUI();
                applyRendererSizing();
                renderInventoryUI();
                renderArmorUI();
                setupEventListeners();
                loadExtensionsFromStorage();
                renderModsList();
                
                // Hide loading screen, show main menu
                updateLoadingProgress(100, 'Game Ready!');
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main-menu').style.display = 'flex';
                    // Keep inventory hidden on spawn
                    document.getElementById('inventory').style.display = 'none';
                    document.getElementById('inventory-trash').style.display = 'none';
                }, 500);
                
                console.log("Game initialized successfully!");
                
                // Start game loop
                animate();
                
            } catch (error) {
                console.error("Error initializing game:", error);
                document.getElementById('loading').innerHTML = `
                    <h1>Error Loading Game</h1>
                    <p>${error.message}</p>
                    <p>Please refresh the page or try a different browser</p>
                `;
            }
        }
        
        function createWorld() {
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = getGroundMaterial();
            if (groundMaterial.map) {
                groundMaterial.map.wrapS = THREE.RepeatWrapping;
                groundMaterial.map.wrapT = THREE.RepeatWrapping;
                groundMaterial.map.repeat.set(50, 50);
            }
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        function createBlockAt(x, y, z, type = 0) {
            if (!blockGeometry) blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            const blockType = (typeof type === 'number' && type >= 0 && type < BLOCK_TYPES.length) ? type : 0;
            const block = new THREE.Mesh(blockGeometry, getMaterialForBlockType(blockType));
            
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            
            block.userData = { type: blockType, key: getBlockKey(x, y, z) };

            if (blockType === CHEST_TYPE) {
                getChestInventoryByKey(block.userData.key);
            }
            
            scene.add(block);
            blocks.push(block);
            return block;
        }
        
        function removeBlockAt(x, y, z) {
            const block = blocks.find(b => 
                Math.round(b.position.x) === Math.round(x) &&
                Math.round(b.position.y) === Math.round(y) &&
                Math.round(b.position.z) === Math.round(z)
            );
            
            if (block) {
                if (block.userData && block.userData.type === CHEST_TYPE) {
                    const chestKey = block.userData.key || getBlockKey(x, y, z);
                    const chest = getChestInventoryByKey(chestKey);
                    chest.forEach((count, idx) => {
                        if (count > 0) {
                            inventoryCounts[idx] = Math.min(MAX_STACK, (inventoryCounts[idx] || 0) + count);
                        }
                    });
                    delete chestInventories[chestKey];
                    if (activeChestKey === chestKey) {
                        toggleChestMenu(false);
                    }
                }
                scene.remove(block);
                blocks = blocks.filter(b => b !== block);
                return true;
            }
            return false;
        }
        
        // ================= HELPER FUNCTIONS =================
        function isMenuOpen() {
            const mainMenu = document.getElementById('main-menu');
            const worldSlots = document.getElementById('world-slots');
            const unavailableMessage = document.getElementById('unavailable-message');
            const renameDialog = document.getElementById('rename-dialog');
            
            return getComputedStyle(mainMenu).display === 'flex' ||
                   getComputedStyle(worldSlots).display === 'flex' ||
                   getComputedStyle(unavailableMessage).display === 'flex' ||
                   getComputedStyle(renameDialog).display === 'flex';
        }
        function isOverlayOpen() {
            const settings = document.getElementById('settings');
            const inventory = document.getElementById('inventory');
            const crafting = document.getElementById('crafting');
            const quickMenu = document.getElementById('quick-menu');
            const chestMenu = document.getElementById('chest-menu');
            const modsMenu = document.getElementById('mods-menu');
            const isSettingsOpen = settings && getComputedStyle(settings).display === 'flex';
            const isInventoryOpen = inventory && getComputedStyle(inventory).display === 'flex';
            const isCraftingOpen = crafting && getComputedStyle(crafting).display === 'flex';
            const isQuickMenuOpen = quickMenu && getComputedStyle(quickMenu).display === 'flex';
            const isChestOpen = chestMenu && getComputedStyle(chestMenu).display === 'flex';
            const isModsOpen = modsMenu && getComputedStyle(modsMenu).display === 'flex';
            return isSettingsOpen || isInventoryOpen || isCraftingOpen || isQuickMenuOpen || isChestOpen || isModsOpen;
        }

        function ensureHotbarSlots(slots) {
            const fallback = [0, 1, 2, 3, 4, 5, 6, 7, 8];
            if (!Array.isArray(slots)) return fallback;
            return fallback.map((value, idx) => {
                const candidate = slots[idx];
                if (typeof candidate === 'number' && candidate >= 0 && candidate < BLOCK_TYPES.length) {
                    return candidate;
                }
                return value;
            });
        }

        function getBlockKey(x, y, z) {
            return `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
        }

        function getChestInventoryByKey(chestKey) {
            if (!chestInventories[chestKey]) {
                chestInventories[chestKey] = BLOCK_TYPES.map(() => 0);
            }
            chestInventories[chestKey] = BLOCK_TYPES.map((_, i) => Math.max(0, chestInventories[chestKey][i] || 0));
            return chestInventories[chestKey];
        }

        function runExtensionHook(hookName, payload = {}) {
            installedExtensions.forEach((ext) => {
                try {
                    if (typeof ext[hookName] === 'function') {
                        ext[hookName](payload);
                    }
                } catch (error) {
                    addChatMessage(`Extension error (${ext.id}): ${error.message}`);
                }
            });
        }

        function getTargetedBlock(maxDistance = 6) {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(blocks);
            if (!intersects.length) return null;
            if (intersects[0].distance > maxDistance) return null;
            return intersects[0].object;
        }

        function getTargetedVillager(maxDistance = 6) {
            const villagerMeshes = villagers.map(v => v.mesh);
            if (!villagerMeshes.length) return null;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(villagerMeshes);
            if (!intersects.length || intersects[0].distance > maxDistance) return null;
            return villagers.find(v => v.mesh === intersects[0].object) || null;
        }

        function updateGameModeUI() {
            const label = document.getElementById('game-mode-label');
            if (label) {
                label.textContent = currentGameMode === 'creative' ? 'Creative' : 'Survival';
            }
        }

        function getArmorReductionPercent() {
            return ARMOR_PIECES.reduce((sum, piece) => sum + (armorSlots[piece] ? ARMOR_REDUCTION[piece] : 0), 0);
        }

        function applyPlayerDamage(amount, source = '') {
            if (currentGameMode === 'creative') return;
            const reduced = amount * (1 - getArmorReductionPercent() / 100);
            myPlayer.health = Math.max(0, myPlayer.health - reduced);
            if (myPlayer.health <= 0) {
                myPlayer.health = 100;
                myPlayer.x = 0;
                myPlayer.y = 10;
                myPlayer.z = 0;
                myPlayer.velocity = { x: 0, y: 0, z: 0 };
                addChatMessage(source ? `You died (${source}) and respawned.` : 'You died and respawned.');
            }
        }

        function renderArmorUI() {
            const armorRoot = document.getElementById('armor-slots');
            const armorValue = document.getElementById('armor-value');
            if (armorValue) {
                armorValue.textContent = `${getArmorReductionPercent()}%`;
            }
            if (!armorRoot) return;
            armorRoot.innerHTML = '';
            ARMOR_PIECES.forEach((piece) => {
                const row = document.createElement('div');
                row.className = 'armor-slot';
                const equipped = armorSlots[piece] ? 'On' : 'Off';
                const available = armorInventory[piece] || 0;
                const canEquip = available > 0 && !armorSlots[piece];
                row.innerHTML = `
                    <span>${piece}</span>
                    <span>${equipped} | ${available}</span>
                    <button>${canEquip ? 'Equip' : (armorSlots[piece] ? 'Unequip' : 'Need')}</button>
                `;
                const btn = row.querySelector('button');
                btn.addEventListener('click', () => {
                    if (canEquip) {
                        armorInventory[piece] -= 1;
                        armorSlots[piece] = 'iron';
                    } else if (armorSlots[piece]) {
                        armorSlots[piece] = null;
                        armorInventory[piece] += 1;
                    }
                    renderArmorUI();
                    saveGameToLocalStorage();
                });
                armorRoot.appendChild(row);
            });
        }

        function playSfx(kind) {
            if (!soundsEnabled) return;
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const map = {
                    place: { freq: 220, dur: 0.04 },
                    break: { freq: 140, dur: 0.05 },
                    craft: { freq: 440, dur: 0.08 },
                    chest: { freq: 280, dur: 0.06 },
                    damage: { freq: 120, dur: 0.12 },
                    villager: { freq: 330, dur: 0.09 },
                    menu: { freq: 500, dur: 0.03 }
                };
                const tone = map[kind] || { freq: 260, dur: 0.05 };
                osc.type = 'square';
                osc.frequency.value = tone.freq;
                gain.gain.value = 0.05;
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + tone.dur);
            } catch (e) {
                console.warn('SFX failed:', e);
            }
        }

        async function startVoiceChat() {
            if (voiceState.active) return;
            try {
                if (!voiceState.stream) {
                    voiceState.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                voiceState.chunks = [];
                voiceState.recorder = new MediaRecorder(voiceState.stream);
                voiceState.recorder.ondataavailable = (e) => voiceState.chunks.push(e.data);
                voiceState.recorder.onstop = () => {
                    const blob = new Blob(voiceState.chunks, { type: 'audio/webm' });
                    const audio = new Audio(URL.createObjectURL(blob));
                    audio.volume = 0.5;
                    audio.play().catch(() => {});
                };
                voiceState.recorder.start();
                voiceState.active = true;
                addChatMessage('Voice chat: recording...');
            } catch (e) {
                addChatMessage('Voice chat failed: microphone not available');
            }
        }

        function stopVoiceChat() {
            if (!voiceState.active) return;
            voiceState.active = false;
            if (voiceState.recorder && voiceState.recorder.state !== 'inactive') {
                voiceState.recorder.stop();
                addChatMessage('Voice chat: sent local clip.');
            }
        }

        function spawnVillagerAt(x, y, z, name = null) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 1.6, 0.7),
                new THREE.MeshPhongMaterial({ color: 0xcdb38b })
            );
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            scene.add(mesh);
            villagers.push({
                id: `villager_${villagerCounter++}`,
                name: name || `Villager ${villagerCounter}`,
                mesh,
                dir: Math.random() * Math.PI * 2,
                timer: Math.random() * 3 + 1.5
            });
        }

        function updateVillagers(deltaTime) {
            villagers.forEach((v) => {
                v.timer -= deltaTime;
                if (v.timer <= 0) {
                    v.timer = Math.random() * 3 + 1.5;
                    v.dir += (Math.random() - 0.5) * 1.8;
                }
                const speed = 0.9;
                v.mesh.position.x += Math.sin(v.dir) * speed * deltaTime;
                v.mesh.position.z += Math.cos(v.dir) * speed * deltaTime;
                v.mesh.position.x = Math.max(-45, Math.min(45, v.mesh.position.x));
                v.mesh.position.z = Math.max(-45, Math.min(45, v.mesh.position.z));
                if (v.mesh.position.y < 1) v.mesh.position.y = 1;
            });
        }

        function normalizeInventoryCounts(counts) {
            return BLOCK_TYPES.map((_, i) => {
                if (counts && typeof counts[i] === 'number') {
                    return Math.max(0, counts[i]);
                }
                return i < BASE_BLOCK_COUNT ? 64 : 0;
            });
        }

        function normalizeStorageCounts(counts) {
            return BLOCK_TYPES.map((_, i) => {
                if (counts && typeof counts[i] === 'number') {
                    return Math.max(0, counts[i]);
                }
                return 0;
            });
        }

        function reconcileRemovedMaterials() {
            removedMaterials = new Set(
                Array.from(removedMaterials).filter((i) => (inventoryCounts[i] || 0) <= 0)
            );
        }

        function ensureValidSelection() {
            if (removedMaterials.has(currentBlockType) && (inventoryCounts[currentBlockType] || 0) <= 0) {
                const nextIndex = BLOCK_TYPES.findIndex((_, i) => !(removedMaterials.has(i) && (inventoryCounts[i] || 0) <= 0));
                if (nextIndex >= 0) {
                    currentBlockType = nextIndex;
                }
            }
        }

        function renderInventoryUI() {
            const inventoryGrid = document.getElementById('inventory-grid');
            const hotbar = document.getElementById('hotbar');
            if (!inventoryGrid || !hotbar) return;

            ensureValidSelection();
            reconcileRemovedMaterials();
            hotbarSlots = ensureHotbarSlots(hotbarSlots);
            const selectedSlot = hotbarSlots.indexOf(currentBlockType);
            currentHotbarSlot = selectedSlot >= 0 ? selectedSlot : currentHotbarSlot;

            inventoryGrid.innerHTML = '';
            hotbar.innerHTML = '';

            BLOCK_TYPES.forEach((block, index) => {
                const count = inventoryCounts[index] || 0;
                const hidden = removedMaterials.has(index) && count <= 0;

                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                if (index === currentBlockType) slot.classList.add('active');
                if (count <= 0) slot.classList.add('disabled');
                slot.dataset.index = index;
                slot.dataset.slotType = 'inventory';
                slot.style.display = hidden ? 'none' : 'flex';
                slot.innerHTML = `<span>${block.emoji}</span><span class="slot-count">${count}</span>`;
                slot.addEventListener('click', () => selectBlockType(index));
                inventoryGrid.appendChild(slot);
            });

            hotbarSlots.forEach((typeIndex, slotIndex) => {
                const hotbarSlot = document.createElement('div');
                const block = BLOCK_TYPES[typeIndex];
                const count = inventoryCounts[typeIndex] || 0;
                const hidden = removedMaterials.has(typeIndex) && count <= 0;
                hotbarSlot.className = 'hotbar-slot';
                if (typeIndex === currentBlockType) hotbarSlot.classList.add('active');
                if (count <= 0) hotbarSlot.classList.add('disabled');
                hotbarSlot.dataset.slotType = 'hotbar';
                hotbarSlot.dataset.hotbarSlot = String(slotIndex);
                hotbarSlot.dataset.index = String(typeIndex);
                hotbarSlot.title = String(slotIndex + 1);
                hotbarSlot.style.display = hidden ? 'none' : 'flex';
                hotbarSlot.innerHTML = `<span>${block.emoji}</span><span class="slot-count">${count}</span>`;
                hotbarSlot.addEventListener('click', () => selectHotbarSlot(slotIndex));
                hotbar.appendChild(hotbarSlot);
            });
        }

        function updateInventoryUI() {
            renderInventoryUI();
            renderArmorUI();
            const inventory = document.getElementById('inventory');
            if (inventory && getComputedStyle(inventory).display === 'flex') {
                setupDragAndDrop();
            }
            renderChestList();
        }

        function selectHotbarSlot(slotIndex) {
            if (slotIndex < 0 || slotIndex >= hotbarSlots.length) return;
            currentHotbarSlot = slotIndex;
            selectBlockType(hotbarSlots[slotIndex]);
        }

        function swapHotbarAndInventory(hotbarSlotIndex, inventoryTypeIndex) {
            const existingSlot = hotbarSlots.findIndex((type) => type === inventoryTypeIndex);
            const oldType = hotbarSlots[hotbarSlotIndex];
            hotbarSlots[hotbarSlotIndex] = inventoryTypeIndex;
            if (existingSlot >= 0 && existingSlot !== hotbarSlotIndex) {
                hotbarSlots[existingSlot] = oldType;
            }
            if (currentHotbarSlot === hotbarSlotIndex || currentBlockType === oldType) {
                currentBlockType = hotbarSlots[currentHotbarSlot];
            }
            updateInventoryUI();
            runExtensionHook('onInventorySwap', {
                source: { type: 'hotbar', slot: hotbarSlotIndex },
                target: { type: 'inventory', index: inventoryTypeIndex }
            });
            saveGameToLocalStorage();
        }

        function isNearCraftingTable() {
            const rangeSq = 9;
            return blocks.some(block => {
                if (!block.userData || block.userData.type !== CRAFTING_TABLE_TYPE) return false;
                const dx = block.position.x - myPlayer.x;
                const dy = block.position.y - myPlayer.y;
                const dz = block.position.z - myPlayer.z;
                return (dx * dx + dy * dy + dz * dz) <= rangeSq;
            });
        }

        function canCraft(recipe) {
            if (currentGameMode === 'creative') return true;
            if (recipe.requiresTable && !isNearCraftingTable()) return false;
            return recipe.ingredients.every(ing => (inventoryCounts[ing.type] || 0) >= ing.count);
        }

        function craftRecipe(recipeId) {
            const recipe = CRAFTING_RECIPES.find(r => r.id === recipeId);
            if (!recipe) return;
            if (!canCraft(recipe)) return;

            if (currentGameMode !== 'creative') {
                recipe.ingredients.forEach(ing => {
                    inventoryCounts[ing.type] = Math.max(0, (inventoryCounts[ing.type] || 0) - ing.count);
                });
            }

            if (recipe.output.kind === 'armor') {
                armorInventory[recipe.output.armorPiece] = (armorInventory[recipe.output.armorPiece] || 0) + (recipe.output.count || 1);
            } else {
                inventoryCounts[recipe.output.type] = Math.min(
                    MAX_STACK,
                    (inventoryCounts[recipe.output.type] || 0) + recipe.output.count
                );
                removedMaterials.delete(recipe.output.type);
            }
            reconcileRemovedMaterials();
            runExtensionHook('onCraft', {
                recipeId: recipe.id,
                outputType: recipe.output.type,
                outputCount: recipe.output.count,
                inventoryCounts: inventoryCounts
            });
            updateInventoryUI();
            renderCraftingList();
            playSfx('craft');
            saveGameToLocalStorage();
            if (recipe.output.kind === 'armor') {
                addChatMessage(`Crafted ${recipe.output.count}x ${recipe.name}`);
            } else {
                addChatMessage(`Crafted ${recipe.output.count}x ${BLOCK_TYPES[recipe.output.type].name}`);
            }
        }

        function renderCraftingList() {
            const list = document.getElementById('crafting-list');
            if (!list) return;
            list.innerHTML = '';

            const hint = document.getElementById('crafting-hint');
            const nearTable = isNearCraftingTable();
            if (hint) {
                hint.textContent = nearTable
                    ? 'Crafting Table detected. Advanced recipes unlocked.'
                    : 'Stand near a Crafting Table to unlock advanced recipes.';
            }

            CRAFTING_RECIPES.forEach(recipe => {
                const card = document.createElement('div');
                card.className = 'recipe-card';

                const grid = document.createElement('div');
                grid.className = 'recipe-grid';
                recipe.grid.forEach(cell => {
                    const cellEl = document.createElement('div');
                    cellEl.className = 'recipe-cell';
                    if (cell !== null && cell !== undefined) {
                        cellEl.textContent = BLOCK_TYPES[cell].emoji;
                    }
                    grid.appendChild(cellEl);
                });

                const output = document.createElement('div');
                output.className = 'recipe-output';
                output.innerHTML = `
                    <span>${recipe.output.kind === 'armor' ? (recipe.output.emoji || '[A]') : BLOCK_TYPES[recipe.output.type].emoji}</span>
                    <span>${recipe.name}</span>
                    <span class="slot-count">x${recipe.output.count}</span>
                `;

                const actions = document.createElement('div');
                actions.className = 'recipe-actions';
                const craftBtn = document.createElement('button');
                const craftable = canCraft(recipe);
                craftBtn.disabled = !craftable;
                if (!craftable && recipe.requiresTable && !nearTable) {
                    craftBtn.textContent = 'Need Table';
                } else if (!craftable) {
                    craftBtn.textContent = 'Missing Items';
                } else {
                    craftBtn.textContent = 'Craft';
                }
                craftBtn.addEventListener('click', () => craftRecipe(recipe.id));
                actions.appendChild(craftBtn);

                card.appendChild(grid);
                card.appendChild(output);
                card.appendChild(actions);
                list.appendChild(card);
            });
        }

        function toggleCrafting() {
            const crafting = document.getElementById('crafting');
            if (!crafting) return;
            const isOpen = getComputedStyle(crafting).display === 'none';
            crafting.style.display = isOpen ? 'flex' : 'none';
            if (isOpen) {
                toggleQuickMenu(false);
                renderCraftingList();
            }
        }

        function openChestForBlock(block) {
            if (!block || !block.userData || (block.userData.type !== CHEST_TYPE && block.userData.type !== ENDER_CHEST_TYPE)) return;
            activeChestType = block.userData.type === ENDER_CHEST_TYPE ? 'ender' : 'normal';
            activeChestKey = getBlockKey(block.position.x, block.position.y, block.position.z);
            getChestInventoryByKey(activeChestKey);
            toggleChestMenu(true);
            const title = document.querySelector('#chest-menu h2');
            if (title) title.textContent = activeChestType === 'ender' ? 'Ender Chest' : 'Chest';
            runExtensionHook('onChestOpen', { chestKey: activeChestKey, chest: activeChestType === 'ender' ? enderChestInventory : chestInventories[activeChestKey] });
            playSfx('chest');
        }

        function toggleChestMenu(forceOpen) {
            const chestMenu = document.getElementById('chest-menu');
            if (!chestMenu) return;
            const shouldOpen = typeof forceOpen === 'boolean'
                ? forceOpen
                : getComputedStyle(chestMenu).display === 'none';
            chestMenu.style.display = shouldOpen ? 'flex' : 'none';
            if (shouldOpen) {
                renderChestList();
            } else {
                activeChestKey = null;
                activeChestType = 'normal';
            }
        }

        function transferPlayerToChest(typeIndex, amount = 1) {
            if (!activeChestKey) return;
            const chest = activeChestType === 'ender' ? enderChestInventory : getChestInventoryByKey(activeChestKey);
            const movable = Math.min(amount, inventoryCounts[typeIndex] || 0);
            if (movable <= 0) return;
            inventoryCounts[typeIndex] = Math.max(0, (inventoryCounts[typeIndex] || 0) - movable);
            chest[typeIndex] = Math.min(MAX_STACK, (chest[typeIndex] || 0) + movable);
            updateInventoryUI();
            saveGameToLocalStorage();
        }

        function transferChestToPlayer(typeIndex, amount = 1) {
            if (!activeChestKey) return;
            const chest = activeChestType === 'ender' ? enderChestInventory : getChestInventoryByKey(activeChestKey);
            const movable = Math.min(amount, chest[typeIndex] || 0);
            if (movable <= 0) return;
            chest[typeIndex] = Math.max(0, (chest[typeIndex] || 0) - movable);
            inventoryCounts[typeIndex] = Math.min(MAX_STACK, (inventoryCounts[typeIndex] || 0) + movable);
            removedMaterials.delete(typeIndex);
            updateInventoryUI();
            saveGameToLocalStorage();
        }

        function quickStoreSelectedItem() {
            transferPlayerToChest(currentBlockType, 1);
        }

        function quickTakeSelectedItem() {
            transferChestToPlayer(currentBlockType, 1);
        }

        function renderChestList() {
            const list = document.getElementById('chest-list');
            if (!list) return;
            if (!activeChestKey) {
                list.innerHTML = '<div style="color:#aaa; text-align:center;">No chest selected.</div>';
                return;
            }
            const chest = activeChestType === 'ender' ? enderChestInventory : getChestInventoryByKey(activeChestKey);
            list.innerHTML = '';

            BLOCK_TYPES.forEach((block, index) => {
                const row = document.createElement('div');
                row.className = 'chest-row';
                row.innerHTML = `
                    <div>${block.emoji} ${block.name}</div>
                    <div>Player: ${inventoryCounts[index] || 0}</div>
                    <div>Chest: ${chest[index] || 0}</div>
                    <button data-action="store">+</button>
                    <button data-action="take">-</button>
                `;
                const buttons = row.querySelectorAll('button');
                buttons[0].addEventListener('click', () => transferPlayerToChest(index, 1));
                buttons[1].addEventListener('click', () => transferChestToPlayer(index, 1));
                list.appendChild(row);
            });
        }

        function interactWithTargetedObject() {
            const villager = getTargetedVillager();
            if (villager) {
                playSfx('villager');
                addChatMessage(`${villager.name}: Hmm... nice weather for blocks.`);
                return;
            }
            const target = getTargetedBlock();
            if (!target || !target.userData) return;
            runExtensionHook('onInteract', { target: target, player: myPlayer });
            if (target.userData.type === CHEST_TYPE || target.userData.type === ENDER_CHEST_TYPE) {
                openChestForBlock(target);
                return;
            }
            if (target.userData.type === CRAFTING_TABLE_TYPE) {
                toggleCrafting();
                return;
            }
        }

        function dropSelectedItem() {
            if (currentGameMode === 'creative') return;
            if ((inventoryCounts[currentBlockType] || 0) <= 0) {
                return;
            }
            inventoryCounts[currentBlockType] = Math.max(0, (inventoryCounts[currentBlockType] || 0) - 1);
            playSfx('break');
            updateInventoryUI();
            saveGameToLocalStorage();
        }

        function toggleQuickMenu(forceOpen) {
            const quickMenu = document.getElementById('quick-menu');
            if (!quickMenu) return;
            const shouldOpen = typeof forceOpen === 'boolean'
                ? forceOpen
                : getComputedStyle(quickMenu).display === 'none';
            quickMenu.style.display = shouldOpen ? 'flex' : 'none';
            if (shouldOpen && document.pointerLockElement) {
                document.exitPointerLock();
                playSfx('menu');
            }
        }

        function handleEscapeAction() {
            const modsMenu = document.getElementById('mods-menu');
            const chestMenu = document.getElementById('chest-menu');
            const settings = document.getElementById('settings');
            const crafting = document.getElementById('crafting');
            const inventory = document.getElementById('inventory');
            const trash = document.getElementById('inventory-trash');
            const quickMenu = document.getElementById('quick-menu');

            if (modsMenu && getComputedStyle(modsMenu).display === 'flex') {
                modsMenu.style.display = 'none';
                return;
            }
            if (chestMenu && getComputedStyle(chestMenu).display === 'flex') {
                toggleChestMenu(false);
                return;
            }
            if (settings && getComputedStyle(settings).display === 'flex') {
                settings.style.display = 'none';
                return;
            }
            if (crafting && getComputedStyle(crafting).display === 'flex') {
                crafting.style.display = 'none';
                return;
            }
            if (inventory && getComputedStyle(inventory).display === 'flex') {
                inventory.style.display = 'none';
                if (trash) trash.style.display = 'none';
                return;
            }
            if (quickMenu && getComputedStyle(quickMenu).display === 'flex') {
                quickMenu.style.display = 'none';
                return;
            }

            toggleQuickMenu(true);
        }

        function saveAndQuitToMenu() {
            saveGameToLocalStorage();
            toggleQuickMenu(false);
            toggleChestMenu(false);
            document.getElementById('inventory').style.display = 'none';
            document.getElementById('crafting').style.display = 'none';
            document.getElementById('settings').style.display = 'none';
            document.getElementById('mods-menu').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('world-slots').style.display = 'none';
            document.getElementById('corner-settings-btn').style.display = 'none';
            applyMobileModeUI();
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function makeMiniBloxAPI() {
            return {
                version: '1.0.0',
                registerMod: (manifest) => registerExtension('mod', manifest),
                registerPlugin: (manifest) => registerExtension('plugin', manifest),
                addRecipe: (recipe) => {
                    if (!recipe || !recipe.id || !recipe.output || !Array.isArray(recipe.ingredients)) {
                        throw new Error('Invalid recipe');
                    }
                    CRAFTING_RECIPES.push(recipe);
                    renderCraftingList();
                },
                addBlockType: (blockDef, startingCount = 0) => {
                    if (!blockDef || !blockDef.name || typeof blockDef.color !== 'number') {
                        throw new Error('Invalid block definition');
                    }
                    BLOCK_TYPES.push({
                        name: blockDef.name,
                        color: blockDef.color,
                        emoji: blockDef.emoji || '[]'
                    });
                    inventoryCounts.push(Math.max(0, startingCount));
                    hotbarSlots = ensureHotbarSlots(hotbarSlots);
                    updateInventoryUI();
                    return BLOCK_TYPES.length - 1;
                },
                addChatMessage: (message) => addChatMessage(`[Mod] ${message}`),
                getState: () => ({
                    player: { ...myPlayer },
                    inventoryCounts: [...inventoryCounts],
                    currentBlockType,
                    gameMode: currentGameMode,
                    armor: { ...armorSlots },
                    villagers: villagers.map(v => ({ id: v.id, x: v.mesh.position.x, y: v.mesh.position.y, z: v.mesh.position.z }))
                })
            };
        }

        function registerExtension(kind, manifest) {
            if (!manifest || typeof manifest !== 'object') {
                throw new Error('Extension manifest must be an object');
            }
            if (!manifest.id || !manifest.name) {
                throw new Error('Extension must include id and name');
            }
            if (installedExtensions.some((ext) => ext.id === manifest.id)) {
                throw new Error(`Extension "${manifest.id}" already installed`);
            }
            const ext = {
                kind,
                id: manifest.id,
                name: manifest.name,
                version: manifest.version || '1.0.0',
                onInit: manifest.onInit,
                onTick: manifest.onTick,
                onCraft: manifest.onCraft,
                onBlockPlace: manifest.onBlockPlace,
                onBlockRemove: manifest.onBlockRemove,
                onInteract: manifest.onInteract,
                onKeyDown: manifest.onKeyDown,
                onInventorySwap: manifest.onInventorySwap,
                onChestOpen: manifest.onChestOpen
            };
            installedExtensions.push(ext);
            if (typeof ext.onInit === 'function') {
                ext.onInit(makeMiniBloxAPI());
            }
            renderModsList();
            addChatMessage(`Installed ${kind}: ${ext.name} (${ext.id})`);
            return ext;
        }

        function installExtensionFromCode(code, persist = true) {
            if (!code || !code.trim()) return;
            const before = installedExtensions.length;
            const installer = new Function('MiniBloxAPI', code);
            installer(makeMiniBloxAPI());
            const after = installedExtensions.length;
            if (after <= before) {
                throw new Error('No extension registered. Use MiniBloxAPI.registerMod/registerPlugin.');
            }
            if (persist) {
                extensionSourceCache.push(code);
                localStorage.setItem('miniblox_extension_sources', JSON.stringify(extensionSourceCache));
            }
            renderModsList();
        }

        function loadExtensionsFromStorage() {
            try {
                extensionSourceCache = JSON.parse(localStorage.getItem('miniblox_extension_sources') || '[]');
                if (!Array.isArray(extensionSourceCache)) {
                    extensionSourceCache = [];
                    return;
                }
                extensionSourceCache.forEach((code) => {
                    try {
                        installExtensionFromCode(code, false);
                    } catch (e) {
                        console.warn('Extension failed to restore:', e);
                    }
                });
            } catch (e) {
                console.warn('Could not load extensions:', e);
            }
        }

        function renderModsList() {
            const modsList = document.getElementById('mods-list');
            if (!modsList) return;
            if (!installedExtensions.length) {
                modsList.innerHTML = '<div style="color:#aaa;">No mods/plugins installed.</div>';
                return;
            }
            modsList.innerHTML = '';
            installedExtensions.forEach((ext) => {
                const row = document.createElement('div');
                row.className = 'mod-item';
                row.innerHTML = `
                    <div>${ext.kind.toUpperCase()}: ${ext.name} <span style="color:#aaa;">(${ext.id})</span></div>
                    <div>v${ext.version}</div>
                `;
                modsList.appendChild(row);
            });
        }

        function toggleModsMenu() {
            const modsMenu = document.getElementById('mods-menu');
            if (!modsMenu) return;
            const isOpen = getComputedStyle(modsMenu).display === 'none';
            modsMenu.style.display = isOpen ? 'flex' : 'none';
            if (isOpen) {
                toggleQuickMenu(false);
                renderModsList();
            }
        }

        function openModFilePicker() {
            document.getElementById('mod-file-input').click();
        }

        function handleModFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    installExtensionFromCode(String(e.target.result || ''), true);
                    addChatMessage(`Loaded extension file: ${file.name}`);
                } catch (error) {
                    addChatMessage(`Failed to load extension: ${error.message}`);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function installModFromTextarea() {
            const input = document.getElementById('mods-code');
            if (!input) return;
            try {
                installExtensionFromCode(input.value, true);
                addChatMessage('Installed extension from text.');
            } catch (error) {
                addChatMessage(`Install failed: ${error.message}`);
            }
        }

        function clearAllModsAndPlugins() {
            installedExtensions = [];
            extensionSourceCache = [];
            localStorage.removeItem('miniblox_extension_sources');
            renderModsList();
            addChatMessage('All mods/plugins removed.');
        }
// ================= INPUT HANDLING =================
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('fullscreenchange', onWindowResize);
            
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                
                // Handle rename dialog keyboard
                if (document.getElementById('rename-dialog').style.display === 'flex') {
                    if (e.key === 'Enter') {
                        confirmRename();
                        e.preventDefault();
                        return;
                    }
                    if (e.key === 'Escape') {
                        cancelRename();
                        e.preventDefault();
                        return;
                    }
                }
                
                // Skip game keybinds if menu is open
                if (isMenuOpen()) {
                    return;
                }

                if (e.key === 'Escape') {
                    if (recordingControl) {
                        const btn = document.getElementById(`btn-${recordingControl}`);
                        if (btn) {
                            btn.classList.remove('recording');
                            btn.textContent = formatKey(controls[recordingControl]);
                        }
                        recordingControl = null;
                    } else {
                        handleEscapeAction();
                    }
                    e.preventDefault();
                    return;
                }
                
                // If recording control, save it
                if (recordingControl) {
                    const action = recordingControl;
                    controls[action] = key;
                    const btn = document.getElementById(`btn-${action}`);
                    btn.classList.remove('recording');
                    btn.textContent = formatKey(key);
                    recordingControl = null;
                    saveControlsToLocalStorage();
                    addChatMessage(`${action} set to ${formatKey(key)}`);
                    e.preventDefault();
                    return;
                }
                
                // Toggle inventory on configured key
                if (key === controls.toggle_inventory || e.key === '~') {
                    toggleInventory();
                    e.preventDefault();
                }
                
                // Toggle settings on configured key
                if (key === controls.open_settings) {
                    toggleSettings();
                    e.preventDefault();
                }

                // Toggle crafting on configured key
                if (key === controls.open_crafting) {
                    toggleCrafting();
                    e.preventDefault();
                }

                if (key === controls.interact) {
                    interactWithTargetedObject();
                    e.preventDefault();
                }

                if (key === controls.drop_item) {
                    dropSelectedItem();
                    e.preventDefault();
                }

                if (key === controls.open_mods) {
                    toggleModsMenu();
                    e.preventDefault();
                }
                if (key === controls.open_armor) {
                    toggleInventory();
                    e.preventDefault();
                }
                if (key === controls.sprint) {
                    sprintEnabled = !sprintEnabled;
                    addChatMessage(`Sprint: ${sprintEnabled ? 'ON' : 'OFF'}`);
                    e.preventDefault();
                }
                if (key === controls.voice_chat) {
                    startVoiceChat();
                    e.preventDefault();
                }
                // Trigger jump on configured key
                if (key === controls.jump && !myPlayer.isFlying && myPlayer.isGrounded) {
                    myPlayer.velocity.y = JUMP_FORCE;
                    myPlayer.isGrounded = false;
                    e.preventDefault();
                } else if (key === controls.jump) {
                    e.preventDefault();
                }
                
                keys[key] = true;
                
                if (key === controls.toggle_chat) {
                    document.getElementById('chat-input').focus();
                    e.preventDefault();
                }
                
                // Block selection
                if (e.key >= '1' && e.key <= '9') {
                    selectHotbarSlot(parseInt(e.key, 10) - 1);
                }
                
                if (key === controls.toggle_fly) {
                    toggleFly();
                }

                runExtensionHook('onKeyDown', { key, rawEvent: e, player: myPlayer });
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
                if (e.key.toLowerCase() === controls.voice_chat) {
                    stopVoiceChat();
                }
            });
            
            // Mouse events
            document.addEventListener('mousedown', (e) => {
                // Handle control recording for mouse buttons
                if (recordingControl === 'mouse_button_4' && e.button === 3) {
                    controls['mouse_button_4'] = 'mousebutton3';
                    const btn = document.getElementById(`btn-mouse_button_4`);
                    btn.classList.remove('recording');
                    btn.textContent = 'M4';
                    recordingControl = null;
                    saveControlsToLocalStorage();
                    addChatMessage('M4 bound successfully!');
                    return;
                }
                if (recordingControl === 'mouse_button_5' && e.button === 4) {
                    controls['mouse_button_5'] = 'mousebutton4';
                    const btn = document.getElementById(`btn-mouse_button_5`);
                    btn.classList.remove('recording');
                    btn.textContent = 'M5';
                    recordingControl = null;
                    saveControlsToLocalStorage();
                    addChatMessage('M5 bound successfully!');
                    return;
                }
                
                // Skip game mouse actions if menu is open
                if (isMenuOpen() || isOverlayOpen()) {
                    return;
                }
                
                // Handle M4 and M5 button actions
                if (e.button === 3) {
                    // M4 button
                    const action = mouseButtonActions.m4;
                    if (action && action !== 'unbound') {
                        executeMouseButtonAction(action);
                    } else if (!m4m5WarningShown) {
                        addChatMessage('Please customize your mouse keybinds in settings');
                        m4m5WarningShown = true;
                    }
                    return;
                }
                if (e.button === 4) {
                    // M5 button
                    const action = mouseButtonActions.m5;
                    if (action && action !== 'unbound') {
                        executeMouseButtonAction(action);
                    } else if (!m4m5WarningShown) {
                        addChatMessage('Please customize your mouse keybinds in settings');
                        m4m5WarningShown = true;
                    }
                    return;
                }
                
                if (e.button === 0) {
                    mouse.isDown = true;
                    placeOrRemoveBlock();
                } else if (e.button === 2) {
                    mouse.rightDown = true;
                    placeOrRemoveBlock(true);
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouse.isDown = false;
                if (e.button === 2) mouse.rightDown = false;
            });
            
            document.addEventListener('mousemove', onMouseMove);
            
            // Prevent right-click menu
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Mouse wheel for switching materials
            document.addEventListener('wheel', (e) => {
                // Don't scroll inventory while in settings, crafting, or inventory
                if (isOverlayOpen()) {
                    return;
                }

                if (document.pointerLockElement !== renderer.domElement) {
                    return;
                }
                
                e.preventDefault();
                if (e.deltaY < 0) {
                    currentHotbarSlot = (currentHotbarSlot - 1 + hotbarSlots.length) % hotbarSlots.length;
                } else {
                    currentHotbarSlot = (currentHotbarSlot + 1) % hotbarSlots.length;
                }
                selectHotbarSlot(currentHotbarSlot);
            }, { passive: false });
            
            // Lock pointer on click
            renderer.domElement.addEventListener('click', () => {
                if (!mobileModeEnabled && !isMenuOpen() && !isOverlayOpen()) {
                    renderer.domElement.requestPointerLock();
                }
            });
        }
        
        function onMouseMove(event) {
            if (document.pointerLockElement === renderer.domElement) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                yaw -= movementX * mouseSensitivity;
                pitch -= movementY * mouseSensitivity;
                
                // Limit pitch
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }
        }
        
        // ================= PLAYER MOVEMENT =================
        function updatePlayerMovement(deltaTime) {
            // Pause physics while menus/overlays are open so the player cannot drift or fall.
            const isUiOpen = isOverlayOpen();
            const isPausedByMenu = isUiOpen || isMenuOpen();
            if (isPausedByMenu) {
                myPlayer.velocity.x = 0;
                myPlayer.velocity.y = 0;
                myPlayer.velocity.z = 0;
                return;
            }
            
            // Apply gravity if not flying
            if (!myPlayer.isFlying) {
                myPlayer.velocity.y += GRAVITY * deltaTime;
            }
            
            // Calculate movement direction (skip if settings open)
            const sprintMultiplier = sprintEnabled ? 1.6 : 1;
            const speed = (myPlayer.isFlying ? 10 : MOVE_SPEED) * sprintMultiplier;
            let moveX = 0;
            let moveZ = 0;
            
            if (!isUiOpen) {
                if (keys[controls.forward]) {
                    moveZ += Math.cos(yaw);
                    moveX += Math.sin(yaw);
                }
                if (keys[controls.backward]) {
                    moveZ -= Math.cos(yaw);
                    moveX -= Math.sin(yaw);
                }
                if (keys[controls.left]) {
                    moveX += Math.cos(yaw);
                    moveZ -= Math.sin(yaw);
                }
                if (keys[controls.right]) {
                    moveX -= Math.cos(yaw);
                    moveZ += Math.sin(yaw);
                }
                if (mobileModeEnabled) {
                    const mobileForward = -mobileInputState.moveY;
                    const mobileStrafe = mobileInputState.moveX;
                    moveZ += mobileForward * Math.cos(yaw);
                    moveX += mobileForward * Math.sin(yaw);
                    moveX += -mobileStrafe * Math.cos(yaw);
                    moveZ += mobileStrafe * Math.sin(yaw);
                }
            }
            
            // Normalize diagonal movement
            if (moveX !== 0 || moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
            }
            
            // Apply movement
            myPlayer.velocity.x = moveX * speed;
            myPlayer.velocity.z = moveZ * speed;
            
            // Jump or fly
            if (myPlayer.isFlying) {
                if (keys[controls.jump] || (!isUiOpen && mobileModeEnabled && mobileInputState.jump)) myPlayer.velocity.y = speed;
                else if (keys.shift) myPlayer.velocity.y = -speed;
                else myPlayer.velocity.y = 0;
            } else if (!isUiOpen && mobileModeEnabled && mobileInputState.jump && myPlayer.isGrounded) {
                myPlayer.velocity.y = JUMP_FORCE;
                myPlayer.isGrounded = false;
            }
            
            // Update position
            myPlayer.x += myPlayer.velocity.x * deltaTime;
            myPlayer.y += myPlayer.velocity.y * deltaTime;
            myPlayer.z += myPlayer.velocity.z * deltaTime;
            
            // Baseplate bounds check - player falls into void if out of bounds
            const baseplateSize = 50; // Half size of the 100x100 baseplate
            if (Math.abs(myPlayer.x) > baseplateSize || Math.abs(myPlayer.z) > baseplateSize) {
                // Out of bounds, apply void damage
                applyPlayerDamage(10 * deltaTime, 'void');
                if (myPlayer.health <= 0) {
                    // Player died - respawn
                    addChatMessage('You fell into the void! Respawned.');
                    saveGameToLocalStorage();
                }
            } else {
                // Simple ground collision only when on baseplate
                if (myPlayer.y < 1 && myPlayer.y > -10) {
                    myPlayer.y = 1;
                    myPlayer.velocity.y = 0;
                    myPlayer.isGrounded = true;
                }
            }

            // Deep void damage regardless of X/Z position
            if (myPlayer.y < -10) {
                applyPlayerDamage(18 * deltaTime, 'void');
            }
            
            // Block collision
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(myPlayer.x, myPlayer.y, myPlayer.z),
                new THREE.Vector3(0.5, 1.8, 0.5)
            );
            
            let colliding = false;
            
            for (const block of blocks) {
                const blockBox = new THREE.Box3().setFromCenterAndSize(
                    block.position,
                    new THREE.Vector3(1, 1, 1)
                );
                
                if (playerBox.intersectsBox(blockBox)) {
                    colliding = true;
                    const blockTop = block.position.y + 0.5;
                    const playerBottom = myPlayer.y - 0.9;
                    
                    // Check if landing on top of block
                    if (playerBottom <= blockTop && playerBottom > blockTop - 0.5 && myPlayer.velocity.y <= 0) {
                        myPlayer.y = blockTop + 0.9;
                        myPlayer.velocity.y = 0;
                        myPlayer.isGrounded = true;
                    } else {
                        // Horizontal collision - push player out of block
                        const blockCenterX = block.position.x;
                        const blockCenterZ = block.position.z;
                        const playerCenterX = myPlayer.x;
                        const playerCenterZ = myPlayer.z;
                        
                        const overlapX = 0.75 - Math.abs(playerCenterX - blockCenterX);
                        const overlapZ = 0.75 - Math.abs(playerCenterZ - blockCenterZ);
                        
                        if (overlapX > 0 && overlapZ > 0) {
                            // Push player out in the direction of least overlap
                            if (overlapX < overlapZ) {
                                if (playerCenterX < blockCenterX) {
                                    myPlayer.x = blockCenterX - 0.75;
                                } else {
                                    myPlayer.x = blockCenterX + 0.75;
                                }
                                myPlayer.velocity.x = 0;
                            } else {
                                if (playerCenterZ < blockCenterZ) {
                                    myPlayer.z = blockCenterZ - 0.75;
                                } else {
                                    myPlayer.z = blockCenterZ + 0.75;
                                }
                                myPlayer.velocity.z = 0;
                            }
                        }
                    }
                }
            }
            
            // Update camera (first person)
            camera.position.set(myPlayer.x, myPlayer.y + 1.7, myPlayer.z);
            
            // Calculate look direction
            const lookX = Math.sin(yaw) * Math.cos(pitch);
            const lookY = Math.sin(pitch);
            const lookZ = Math.cos(yaw) * Math.cos(pitch);
            
            camera.lookAt(
                myPlayer.x + lookX,
                myPlayer.y + 1.7 + lookY,
                myPlayer.z + lookZ
            );
            
            // Update UI
            document.getElementById('position').textContent = 
                `${myPlayer.x.toFixed(1)}, ${myPlayer.y.toFixed(1)}, ${myPlayer.z.toFixed(1)}`;
            document.getElementById('health').textContent = Math.max(0, Math.floor(myPlayer.health));
            const armorValue = document.getElementById('armor-value');
            if (armorValue) armorValue.textContent = `${getArmorReductionPercent()}%`;
            
            // Update health bar width (0-100 health scale)
            const healthPercentage = Math.max(0, Math.min(100, myPlayer.health));
            document.getElementById('health-fill').style.width = healthPercentage + '%';
        }
        
        // ================= BLOCK INTERACTION =================
                function placeOrRemoveBlock(remove = false) {
            // Don't place/remove blocks if UI overlays are open
            if (isOverlayOpen()) {
                return;
            }
            
            // Check inventory before placing
            if (!remove && currentGameMode !== 'creative' && (inventoryCounts[currentBlockType] || 0) <= 0) {
                addChatMessage(`Out of ${BLOCK_TYPES[currentBlockType].name}!`);
                return;
            }
            
            // Create a raycaster from camera center
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObjects([...blocks, ground]);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const block = intersect.object;
                const point = intersect.point;
                const normal = intersect.face.normal;
                
                if (remove) {
                    // Remove block
                    const removedType = block.userData ? block.userData.type : 0;
                    if (removeBlockAt(block.position.x, block.position.y, block.position.z)) {
                        if (currentGameMode !== 'creative') {
                            inventoryCounts[removedType] = Math.min(MAX_STACK, (inventoryCounts[removedType] || 0) + 1);
                            removedMaterials.delete(removedType);
                        }
                        runExtensionHook('onBlockRemove', { x: block.position.x, y: block.position.y, z: block.position.z, type: removedType });
                        playSfx('break');
                        updateInventoryUI();
                        saveGameToLocalStorage();
                    }
                } else {
                    // Place new block
                    const newX = Math.round(point.x + normal.x * 0.5);
                    const newY = Math.round(point.y + normal.y * 0.5);
                    const newZ = Math.round(point.z + normal.z * 0.5);
                    
                    // Check if position is empty
                    const existing = blocks.find(b => 
                        Math.round(b.position.x) === newX &&
                        Math.round(b.position.y) === newY &&
                        Math.round(b.position.z) === newZ
                    );
                    
                    if (!existing) {
                        createBlockAt(newX, newY, newZ, currentBlockType);
                        if (currentGameMode !== 'creative') {
                            inventoryCounts[currentBlockType] = Math.max(0, (inventoryCounts[currentBlockType] || 0) - 1);
                        }
                        runExtensionHook('onBlockPlace', { x: newX, y: newY, z: newZ, type: currentBlockType });
                        playSfx('place');
                        updateInventoryUI();
                        saveGameToLocalStorage();
                    }
                }
            }

            if (myPlayer.y < -10) {
                applyPlayerDamage(18 * deltaTime, 'deep fall');
            }
        }

                function spawnBlock() {
            const distance = 5;
            const x = myPlayer.x + Math.sin(yaw) * distance;
            const z = myPlayer.z + Math.cos(yaw) * distance;
            const y = myPlayer.y + 1;
            
            createBlockAt(x, y, z, currentBlockType);
        }
        
        function selectBlockType(type) {
            if (type >= 0 && type < BLOCK_TYPES.length) {
                currentBlockType = type;
                const slotIndex = hotbarSlots.indexOf(type);
                if (slotIndex >= 0) {
                    currentHotbarSlot = slotIndex;
                }
                updateInventoryUI();
                saveGameToLocalStorage();
            }
        }
        
        function toggleSettings() {
            const settings = document.getElementById('settings');
            const isOpen = getComputedStyle(settings).display === 'none';
            settings.style.display = isOpen ? 'flex' : 'none';
            if (isOpen) {
                toggleQuickMenu(false);
                renderControlsList();
            }
        }
        
        function renderControlsList() {
            const controlsList = document.getElementById('controls-list');
            controlsList.innerHTML = '';
            
            const sensitivityRow = document.createElement('div');
            sensitivityRow.className = 'control-row';
            sensitivityRow.innerHTML = `
                <span class="control-label">Mouse Sensitivity</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" min="0.0005" max="0.01" step="0.0005" value="${mouseSensitivity}" oninput="updateMouseSensitivity(this.value)" style="flex: 1;">
                    <span id="sensitivity-value" style="color: #fff; min-width: 50px; text-align: right;">${formatSensitivity(mouseSensitivity)}</span>
                </div>
            `;
            controlsList.appendChild(sensitivityRow);

            const screenSizeRow = document.createElement('div');
            screenSizeRow.className = 'control-row';
            screenSizeRow.innerHTML = `
                <span class="control-label">Screen Size</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" min="0.6" max="1" step="0.05" value="${screenScale}" oninput="updateScreenScale(this.value)" style="flex: 1;">
                    <span id="screen-size-value" style="color: #fff; min-width: 50px; text-align: right;">${formatPercent(screenScale)}</span>
                </div>
            `;
            controlsList.appendChild(screenSizeRow);

            const renderScaleRow = document.createElement('div');
            renderScaleRow.className = 'control-row';
            renderScaleRow.innerHTML = `
                <span class="control-label">Render Quality</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" min="0.5" max="1" step="0.05" value="${renderScale}" oninput="updateRenderScale(this.value)" style="flex: 1;">
                    <span id="render-scale-value" style="color: #fff; min-width: 50px; text-align: right;">${formatPercent(renderScale)}</span>
                </div>
            `;
            controlsList.appendChild(renderScaleRow);

            const fullscreenRow = document.createElement('div');
            fullscreenRow.className = 'control-row';
            fullscreenRow.innerHTML = `
                <span class="control-label">Fullscreen</span>
                <button class="control-key" onclick="toggleFullscreenMode()">Toggle</button>
            `;
            controlsList.appendChild(fullscreenRow);

            const mobileModeRow = document.createElement('div');
            mobileModeRow.className = 'control-row';
            mobileModeRow.innerHTML = `
                <span class="control-label">Mobile Controls</span>
                <select onchange="setMobileMode(this.value === 'true')" style="padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                    <option value="true" ${mobileModeEnabled ? 'selected' : ''}>Enabled</option>
                    <option value="false" ${!mobileModeEnabled ? 'selected' : ''}>Disabled</option>
                </select>
            `;
            controlsList.appendChild(mobileModeRow);
            
            // Keyboard Controls Section
            const controlLabels = {
                forward: 'Move Forward',
                backward: 'Move Backward',
                left: 'Move Left',
                right: 'Move Right',
                jump: 'Jump/Fly Up',
                toggle_chat: 'Open Chat',
                toggle_fly: 'Toggle Fly Mode',
                toggle_inventory: 'Open Inventory',
                open_settings: 'Open Settings',
                open_crafting: 'Open Crafting',
                interact: 'Interact',
                drop_item: 'Drop Selected Item',
                open_mods: 'Open Mods & Plugins',
                open_armor: 'Open Armor',
                sprint: 'Toggle Sprint',
                voice_chat: 'Push To Talk'
            };
            
            for (const [action, label] of Object.entries(controlLabels)) {
                const row = document.createElement('div');
                row.className = 'control-row';
                row.innerHTML = `
                    <span class="control-label">${label}</span>
                    <button class="control-key" onclick="startRecordingControl('${action}')" id="btn-${action}">
                        ${formatKey(controls[action])}
                    </button>
                `;
                controlsList.appendChild(row);
            }
            
            // Mouse Button Actions Section
            const separator = document.createElement('div');
            separator.style.borderTop = '1px solid rgba(255,255,255,0.2)';
            separator.style.margin = '15px 0';
            controlsList.appendChild(separator);
            
            const mouseTitle = document.createElement('div');
            mouseTitle.style.color = '#fff';
            mouseTitle.style.fontWeight = 'bold';
            mouseTitle.style.marginBottom = '10px';
            mouseTitle.textContent = 'Mouse Buttons';
            controlsList.appendChild(mouseTitle);
            
            const m4Row = document.createElement('div');
            m4Row.className = 'control-row';
            m4Row.innerHTML = `
                <span class="control-label">Mouse Button 4 (M4)</span>
                <select id="m4-action" onchange="updateMouseButtonAction('m4', this.value)" style="padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                    ${availableActions.map(action => `<option value="${action.id}" ${mouseButtonActions.m4 === action.id ? 'selected' : ''}>${action.label}</option>`).join('')}
                </select>
            `;
            controlsList.appendChild(m4Row);
            
            const m5Row = document.createElement('div');
            m5Row.className = 'control-row';
            m5Row.innerHTML = `
                <span class="control-label">Mouse Button 5 (M5)</span>
                <select id="m5-action" onchange="updateMouseButtonAction('m5', this.value)" style="padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                    ${availableActions.map(action => `<option value="${action.id}" ${mouseButtonActions.m5 === action.id ? 'selected' : ''}>${action.label}</option>`).join('')}
                </select>
            `;
            controlsList.appendChild(m5Row);
        }

        function formatSensitivity(value) {
            return (value * 1000).toFixed(1);
        }

        function updateMouseSensitivity(value) {
            const parsed = parseFloat(value);
            if (Number.isNaN(parsed)) return;
            mouseSensitivity = parsed;
            const label = document.getElementById('sensitivity-value');
            if (label) {
                label.textContent = formatSensitivity(mouseSensitivity);
            }
            saveControlsToLocalStorage();
        }

        function formatKey(key) {
            if (key === ' ') return 'SPACE';
            if (key === '`') return 'BACKTICK';
            if (key === 'unbound') return 'UNBOUND';
            if (key === 'mousebutton3') return 'M4';
            if (key === 'mousebutton4') return 'M5';
            return key.toUpperCase();
        }

        function updateMouseButtonAction(button, actionId) {
            mouseButtonActions[button] = actionId;
            saveControlsToLocalStorage();
            addChatMessage(`${button.toUpperCase()} action set to ${availableActions.find(a => a.id === actionId).label}`);
        }

        function executeMouseButtonAction(actionId) {
            if (actionId === 'unbound') return;
            if (isOverlayOpen()) {
                return;
            }
            
            switch (actionId) {
                case 'place_block':
                    placeOrRemoveBlock(false);
                    break;
                case 'remove_block':
                    placeOrRemoveBlock(true);
                    break;
                case 'toggle_fly':
                    myPlayer.isFlying = !myPlayer.isFlying;
                    addChatMessage(myPlayer.isFlying ? 'Fly mode ON' : 'Fly mode OFF');
                    break;
                case 'toggle_inventory':
                    toggleInventory();
                    break;
                case 'toggle_crafting':
                    toggleCrafting();
                    break;
                case 'interact':
                    interactWithTargetedObject();
                    break;
                case 'drop_item':
                    dropSelectedItem();
                    break;
                case 'open_mods':
                    toggleModsMenu();
                    break;
                case 'open_armor':
                    toggleInventory();
                    break;
            }
        }

        function startRecordingControl(action) {
            recordingControl = action;
            const btn = document.getElementById(`btn-${action}`);
            btn.classList.add('recording');
            btn.textContent = action.includes('mouse_button') ? 'Click mouse button...' : 'Press any key...';
        }

        function resetControlsToDefault() {
            controls = { ...defaultControls };
            mouseButtonActions = {
                m4: 'unbound',
                m5: 'unbound'
            };
            mouseSensitivity = DEFAULT_MOUSE_SENSITIVITY;
            screenScale = 1;
            renderScale = 1;
            mobileModeEnabled = isTouchDevice;
            applyMobileModeUI();
            applyRendererSizing();
            renderControlsList();
            saveControlsToLocalStorage();
            addChatMessage('Controls reset to default!');
        }

        function toggleInventory() {
            const inventory = document.getElementById('inventory');
            const trash = document.getElementById('inventory-trash');
            const isOpen = getComputedStyle(inventory).display === 'none';
            inventory.style.display = isOpen ? 'flex' : 'none';
            trash.style.display = isOpen ? 'flex' : 'none';
            
            if (isOpen) {
                toggleQuickMenu(false);
                updateInventoryUI();
                setupDragAndDrop();
            }
        }

        function setupDragAndDrop() {
            const inventorySlots = document.querySelectorAll('#inventory-grid .inventory-slot');
            const hotbarUiSlots = document.querySelectorAll('#hotbar .hotbar-slot');
            const trash = document.getElementById('inventory-trash');
            let draggedPayload = null;
            
            const allSlots = [...inventorySlots, ...hotbarUiSlots];
            allSlots.forEach((slot) => {
                const slotType = slot.dataset.slotType;
                const index = parseInt(slot.dataset.index, 10);
                if (Number.isNaN(index) || !slotType) return;
                slot.draggable = true;
                
                slot.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    slot.style.opacity = '0.5';
                    draggedPayload = {
                        slotType: slotType,
                        index: index,
                        hotbarSlot: parseInt(slot.dataset.hotbarSlot || '-1', 10)
                    };
                });
                
                slot.addEventListener('dragend', () => {
                    slot.style.opacity = '1';
                    draggedPayload = null;
                    slot.classList.remove('swap-hover');
                });

                slot.addEventListener('dragover', (e) => {
                    if (!draggedPayload) return;
                    e.preventDefault();
                    slot.classList.add('swap-hover');
                });

                slot.addEventListener('dragleave', () => {
                    slot.classList.remove('swap-hover');
                });

                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slot.classList.remove('swap-hover');
                    if (!draggedPayload) return;

                    const targetType = slot.dataset.slotType;
                    const targetIndex = parseInt(slot.dataset.index, 10);
                    const targetHotbarSlot = parseInt(slot.dataset.hotbarSlot || '-1', 10);

                    if (targetType === 'inventory' && draggedPayload.slotType === 'inventory') {
                        const a = draggedPayload.index;
                        const b = targetIndex;
                        const temp = inventoryCounts[a] || 0;
                        inventoryCounts[a] = inventoryCounts[b] || 0;
                        inventoryCounts[b] = temp;
                    } else if (targetType === 'hotbar' && draggedPayload.slotType === 'hotbar') {
                        const a = draggedPayload.hotbarSlot;
                        const b = targetHotbarSlot;
                        if (a >= 0 && b >= 0) {
                            const tempType = hotbarSlots[a];
                            hotbarSlots[a] = hotbarSlots[b];
                            hotbarSlots[b] = tempType;
                        }
                    } else if (targetType === 'hotbar' && draggedPayload.slotType === 'inventory') {
                        swapHotbarAndInventory(targetHotbarSlot, draggedPayload.index);
                        return;
                    } else if (targetType === 'inventory' && draggedPayload.slotType === 'hotbar') {
                        swapHotbarAndInventory(draggedPayload.hotbarSlot, targetIndex);
                        return;
                    }

                    runExtensionHook('onInventorySwap', {
                        source: draggedPayload,
                        target: { slotType: targetType, index: targetIndex, hotbarSlot: targetHotbarSlot }
                    });
                    updateInventoryUI();
                    saveGameToLocalStorage();
                });
            });
            
            trash.ondragover = (e) => {
                if (!draggedPayload) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                trash.classList.add('drag-over');
            };
            
            trash.ondragleave = () => {
                trash.classList.remove('drag-over');
            };
            
            trash.ondrop = (e) => {
                e.preventDefault();
                trash.classList.remove('drag-over');
                
                if (draggedPayload !== null && draggedPayload.slotType === 'inventory') {
                    inventoryCounts[draggedPayload.index] = 0;
                    removedMaterials.add(draggedPayload.index);
                    updateInventoryUI();
                    addChatMessage(`Removed ${BLOCK_TYPES[draggedPayload.index].emoji} from inventory!`);
                    saveGameToLocalStorage();
                }
            };
        }

        // ================= CONVERSATION SYSTEM =================
        let currentConversationId = null;
        let renamingConversationId = null;
        
        function saveConversation() {
            const messagesDiv = document.getElementById('messages');
            const messageElements = messagesDiv.querySelectorAll('div');
            const messages = Array.from(messageElements).map(el => el.textContent);
            
            if (messages.length === 0) return;
            
            const conversationId = currentConversationId || `conv_${Date.now()}`;
            currentConversationId = conversationId;
            
            const conversationData = {
                id: conversationId,
                messages: messages,
                timestamp: new Date().getTime(),
                date: new Date().toLocaleString()
            };
            
            try {
                localStorage.setItem(`miniblox_conversation_${conversationId}`, JSON.stringify(conversationData));
                
                // Update conversation index
                let conversationIndex = JSON.parse(localStorage.getItem('miniblox_conversation_index') || '[]');
                if (!conversationIndex.find(c => c.id === conversationId)) {
                    conversationIndex.push({ id: conversationId, date: conversationData.date });
                    localStorage.setItem('miniblox_conversation_index', JSON.stringify(conversationIndex));
                }
            } catch (e) {
                console.warn('Could not save conversation:', e);
            }
        }
        
        function loadConversation() {
            try {
                let conversationIndex = JSON.parse(localStorage.getItem('miniblox_conversation_index') || '[]');
                const conversationsList = document.getElementById('conversations-list');
                conversationsList.innerHTML = '';

                // Prune any index entries that no longer have data
                conversationIndex = conversationIndex.filter(convMeta => {
                    return localStorage.getItem(`miniblox_conversation_${convMeta.id}`) !== null;
                });
                localStorage.setItem('miniblox_conversation_index', JSON.stringify(conversationIndex));
                
                if (conversationIndex.length === 0) {
                    conversationsList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No saved conversations</div>';
                    document.getElementById('conversation-load-dialog').style.display = 'flex';
                    return;
                }

                const orderedIndex = [...conversationIndex].reverse();
                orderedIndex.forEach(convMeta => {
                    const convData = JSON.parse(localStorage.getItem(`miniblox_conversation_${convMeta.id}`));
                    if (convData) {
                        const item = document.createElement('div');
                        item.className = 'conversation-item';
                        
                        const messageCount = convData.messages.length;
                        const displayName = convMeta.name || `Conversation ${messageCount} messages`;
                        item.innerHTML = `
                            <div class="conversation-item-title">üí¨ ${displayName}</div>
                            <div class="conversation-item-info">Saved: ${convData.date}</div>
                            <div class="conversation-item-info" style="margin-top: 5px; color: #aaa;">${convData.messages[0] ? convData.messages[0].substring(0, 50) + '...' : 'Empty'}</div>
                            <div class="conversation-item-buttons">
                                <button class="conversation-item-button" onclick="loadConversationData('${convMeta.id}')">Load</button>
                                <button class="conversation-item-button" onclick="openConversationRenameDialog('${convMeta.id}')">Rename</button>
                                <button class="conversation-item-button delete" onclick="deleteConversation('${convMeta.id}')">Delete</button>
                            </div>
                        `;
                        conversationsList.appendChild(item);
                    }
                });
                
                document.getElementById('conversation-load-dialog').style.display = 'flex';
            } catch (e) {
                console.warn('Could not load conversations:', e);
            }
        }
        
        function loadConversationData(conversationId) {
            try {
                const conversationData = JSON.parse(localStorage.getItem(`miniblox_conversation_${conversationId}`));
                if (conversationData) {
                    currentConversationId = conversationId;
                    const messagesDiv = document.getElementById('messages');
                    messagesDiv.innerHTML = '';
                    conversationData.messages.forEach(msg => {
                        messagesDiv.innerHTML += `<div>${msg}</div>`;
                    });
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    document.getElementById('conversation-load-dialog').style.display = 'none';
                    addChatMessage(`[Loaded conversation with ${conversationData.messages.length} messages]`);
                }
            } catch (e) {
                console.warn('Could not load conversation data:', e);
            }
        }
        
        function closeConversationDialog() {
            document.getElementById('conversation-load-dialog').style.display = 'none';
        }
        
        function openConversationRenameDialog(conversationId) {
            renamingConversationId = conversationId;
            const conversationIndex = JSON.parse(localStorage.getItem('miniblox_conversation_index') || '[]');
            const convMeta = conversationIndex.find(c => c.id === conversationId);
            const currentName = convMeta ? (convMeta.name || `Conversation`) : 'Conversation';
            
            document.getElementById('conversation-rename-input').value = currentName;
            document.getElementById('conversation-rename-dialog').style.display = 'flex';
            document.getElementById('conversation-rename-input').focus();
        }
        
        function confirmConversationRename() {
            const newName = document.getElementById('conversation-rename-input').value.trim();
            
            if (!newName) {
                alert('Please enter a conversation name!');
                return;
            }
            
            try {
                const conversationIndex = JSON.parse(localStorage.getItem('miniblox_conversation_index') || '[]');
                const convMeta = conversationIndex.find(c => c.id === renamingConversationId);
                if (convMeta) {
                    convMeta.name = newName;
                    localStorage.setItem('miniblox_conversation_index', JSON.stringify(conversationIndex));
                    addChatMessage(`Conversation renamed to "${newName}"`);
                }
                document.getElementById('conversation-rename-dialog').style.display = 'none';
                loadConversation();
            } catch (e) {
                console.warn('Could not rename conversation:', e);
            }
        }
        
        function cancelConversationRename() {
            document.getElementById('conversation-rename-dialog').style.display = 'none';
            document.getElementById('conversation-rename-input').value = '';
            renamingConversationId = null;
        }
        
        function deleteConversation(conversationId) {
            if (confirm('Delete this conversation? This cannot be undone!')) {
                try {
                    localStorage.removeItem(`miniblox_conversation_${conversationId}`);
                    let conversationIndex = JSON.parse(localStorage.getItem('miniblox_conversation_index') || '[]');
                    conversationIndex = conversationIndex.filter(c => c.id !== conversationId);
                    localStorage.setItem('miniblox_conversation_index', JSON.stringify(conversationIndex));
                    if (currentConversationId === conversationId) {
                        currentConversationId = null;
                    }
                    loadConversation();
                } catch (e) {
                    console.warn('Could not delete conversation:', e);
                }
            }
        }

        function deleteAllConversations() {
            if (!confirm('Delete all conversations? This cannot be undone!')) {
                return;
            }

            try {
                const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('miniblox_conversation_')) {
                        keysToRemove.push(key);
                    }
                }

                keysToRemove.forEach(key => localStorage.removeItem(key));
                currentConversationId = null;
                loadConversation();
            } catch (e) {
                console.warn('Could not delete all conversations:', e);
            }
        }
        
        // ================= UI FUNCTIONS =================
        function handleChatKey(e) {
            if (e.key === 'Enter') {
                const input = document.getElementById('chat-input');
                const text = input.value.trim();
                
                if (text) {
                    if (text.startsWith('/')) {
                        handleCommand(text);
                    } else {
                        addChatMessage(`You: ${text}`);
                    }
                    input.value = '';
                }
            }
        }
        
        function handleCommand(cmd) {
            const args = cmd.substring(1).split(' ');
            switch(args[0].toLowerCase()) {
                case 'help':
                    addChatMessage('Commands: /tp [x] [y] [z], /fly, /heal, /clear, /gamemode [survival|creative], /sound [on|off]');
                    break;
                case 'tp':
                    if (args.length >= 4) {
                        myPlayer.x = parseFloat(args[1]) || 0;
                        myPlayer.y = parseFloat(args[2]) || 10;
                        myPlayer.z = parseFloat(args[3]) || 0;
                        addChatMessage(`Teleported to (${myPlayer.x}, ${myPlayer.y}, ${myPlayer.z})`);
                    }
                    break;
                case 'fly':
                    toggleFly();
                    break;
                case 'heal':
                    myPlayer.health = 100;
                    addChatMessage('Healed to full health!');
                    saveGameToLocalStorage();
                    break;
                case 'clear':
                    blocks.forEach(block => scene.remove(block));
                    blocks = [];
                    chestInventories = {};
                    activeChestKey = null;
                    villagers.forEach(v => scene.remove(v.mesh));
                    villagers = [];
                    addChatMessage('Cleared all blocks');
                    createWorld();
                    break;
                case 'gamemode':
                    if (args[1] === 'creative' || args[1] === 'survival') {
                        currentGameMode = args[1];
                        if (currentGameMode === 'creative') {
                            myPlayer.isFlying = true;
                            inventoryCounts = BLOCK_TYPES.map(() => MAX_STACK);
                        }
                        updateGameModeUI();
                        updateInventoryUI();
                        addChatMessage(`Gamemode set to ${currentGameMode}`);
                        saveGameToLocalStorage();
                    }
                    break;
                case 'sound':
                    if (args[1] === 'on' || args[1] === 'off') {
                        soundsEnabled = args[1] === 'on';
                        addChatMessage(`Sounds ${soundsEnabled ? 'enabled' : 'disabled'}.`);
                    }
                    break;
                default:
                    addChatMessage('Unknown command. Type /help for commands.');
            }
        }
        
        function addChatMessage(msg) {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<div>${msg}</div>`;
            messages.scrollTop = messages.scrollHeight;
            saveConversation();
        }
        
        function saveChatToFile() {
            const messagesDiv = document.getElementById('messages');
            const messageElements = messagesDiv.querySelectorAll('div');
            let chatContent = 'MiniBlox Pro - Chat Log\n';
            chatContent += '='.repeat(50) + '\n\n';
            
            messageElements.forEach(element => {
                chatContent += element.textContent + '\n';
            });
            
            const blob = new Blob([chatContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `miniblox_chat_${new Date().getTime()}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            addChatMessage('Chat saved to file!');
        }
        
        function saveGameToFile() {
            const gameState = {
                player: {
                    x: myPlayer.x,
                    y: myPlayer.y,
                    z: myPlayer.z,
                    health: myPlayer.health,
                    isFlying: myPlayer.isFlying
                },
                gameMode: currentGameMode,
                blocks: blocks.map(block => ({
                    x: block.position.x,
                    y: block.position.y,
                    z: block.position.z,
                    type: block.userData.type
                })),
                villagers: villagers.map(v => ({
                    id: v.id,
                    name: v.name,
                    x: v.mesh.position.x,
                    y: v.mesh.position.y,
                    z: v.mesh.position.z
                })),
                currentBlockType: currentBlockType,
                hotbarSlots: hotbarSlots,
                removedMaterials: Array.from(removedMaterials),
                inventoryCounts: inventoryCounts,
                chestInventories: chestInventories,
                enderChestInventory: enderChestInventory,
                armorSlots: armorSlots,
                armorInventory: armorInventory,
                saveTime: new Date().toLocaleString()
            };
            
            const blob = new Blob([JSON.stringify(gameState, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `miniblox_save_${new Date().getTime()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            addChatMessage('Game saved to file!');
        }

        function downloadTextFile(filename, content, mimeType = 'text/plain') {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function downloadAppVersion() {
            addChatMessage('App version download is currently unavailable.');
            alert('App version download is currently unavailable.');
        }
        
        function loadGameFromFile() {
            document.getElementById('game-file-input').click();
        }
        
                function handleLoadGameFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const gameState = JSON.parse(e.target.result);
                    
                    // Restore player state
                    myPlayer.x = gameState.player.x;
                    myPlayer.y = gameState.player.y;
                    myPlayer.z = gameState.player.z;
                    myPlayer.health = gameState.player.health;
                    myPlayer.isFlying = gameState.player.isFlying;
                    currentGameMode = gameState.gameMode || 'survival';
                    
                    // Clear existing blocks
                    blocks.forEach(block => scene.remove(block));
                    blocks = [];
                    activeChestKey = null;
                    document.getElementById('chest-menu').style.display = 'none';
                    villagers.forEach(v => scene.remove(v.mesh));
                    villagers = [];
                    // Restore blocks
                    gameState.blocks.forEach(blockData => {
                        createBlockAt(blockData.x, blockData.y, blockData.z, blockData.type);
                    });
                    (gameState.villagers || []).forEach(v => spawnVillagerAt(v.x, v.y, v.z, v.name));
                    
                    // Restore other state
                    currentBlockType = gameState.currentBlockType;
                    inventoryCounts = gameState.gameMode === 'creative' && !gameState.inventoryCounts
                        ? BLOCK_TYPES.map(() => MAX_STACK)
                        : normalizeInventoryCounts(gameState.inventoryCounts);
                    hotbarSlots = ensureHotbarSlots(gameState.hotbarSlots);
                    removedMaterials = new Set(gameState.removedMaterials || []);
                    chestInventories = gameState.chestInventories || {};
                    enderChestInventory = normalizeStorageCounts(gameState.enderChestInventory || []);
                    armorSlots = gameState.armorSlots || { helmet: null, chestplate: null, leggings: null, boots: null };
                    armorInventory = gameState.armorInventory || { helmet: 0, chestplate: 0, leggings: 0, boots: 0 };
                    reconcileRemovedMaterials();
                    renderInventoryUI();
                    updateGameModeUI();
                    selectBlockType(currentBlockType);
                    
                    // Update UI
                    document.getElementById('health').textContent = Math.max(0, Math.floor(myPlayer.health));
                    const healthPercentage = Math.max(0, Math.min(100, myPlayer.health));
                    document.getElementById('health-fill').style.width = healthPercentage + '%';
                    
                    addChatMessage('Game loaded successfully!');
                } catch (error) {
                    addChatMessage('Error loading game file: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input so the same file can be loaded again
            event.target.value = '';
        }
        
        function toggleFly() {
            myPlayer.isFlying = !myPlayer.isFlying;
            const flyBtn = document.getElementById('fly-btn');
            flyBtn.textContent = `‚úàÔ∏è Fly: ${myPlayer.isFlying ? 'ON' : 'OFF'}`;
            flyBtn.style.background = myPlayer.isFlying ? '#ff8800' : '#00a2ff';
            
            addChatMessage(`Fly mode: ${myPlayer.isFlying ? 'ENABLED' : 'DISABLED'}`);
        }
        
        function onWindowResize() {
            applyRendererSizing();
        }
        
        // ================= GAME LOOP =================
        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Calculate delta time
            const deltaTime = lastTime ? (currentTime - lastTime) / 1000 : 0.016;
            lastTime = currentTime;
            
            // Auto-save periodically
            if (currentTime - lastAutoSaveTime > AUTO_SAVE_INTERVAL) {
                saveGameToLocalStorage();
                lastAutoSaveTime = currentTime;
            }
            
            // Update player movement
            updatePlayerMovement(deltaTime);
            updateVillagers(deltaTime);
            runExtensionHook('onTick', { deltaTime, player: myPlayer, inventoryCounts: inventoryCounts });
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // ================= START GAME =================
        // Wait for page to load
        window.addEventListener('load', () => {
            console.log("Page loaded, starting game...");
            init();
        });
        
        // Fallback in case load event doesn't fire
        setTimeout(() => {
            if (!scene) {
                console.log("Starting game via timeout...");
                init();
            }
        }, 1000);
    </script>
</body>
</html>





